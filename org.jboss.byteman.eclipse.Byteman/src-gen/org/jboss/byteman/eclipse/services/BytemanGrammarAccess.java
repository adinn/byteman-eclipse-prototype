/*
* generated by Xtext
*/

package org.jboss.byteman.eclipse.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class BytemanGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class DomainModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDomainModelAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cElementsAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cElementsElementParserRuleCall_1_0_0 = (RuleCall)cElementsAssignment_1_0.eContents().get(0);
		private final RuleCall cEOLTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		/// *
		//	Specification of the domain model allowing multiple rules in one script
		//	Specification of individual rules using event, condition and action
		//	
		//	n.b. WS and comments are hidden in the top level rules but there is
		//	explicit end of line (EOL) handling because the RULE, CLASS/INTERFACE,
		//	METHOD, AT and ENDRULE keyword elements of the rule are line oriented
		// * / DomainModel:
		//	{DomainModel} (elements+=Element | EOL)*;
		public ParserRule getRule() { return rule; }

		//{DomainModel} (elements+=Element | EOL)*
		public Group getGroup() { return cGroup; }

		//{DomainModel}
		public Action getDomainModelAction_0() { return cDomainModelAction_0; }

		//(elements+=Element | EOL)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//elements+=Element
		public Assignment getElementsAssignment_1_0() { return cElementsAssignment_1_0; }

		//Element
		public RuleCall getElementsElementParserRuleCall_1_0_0() { return cElementsElementParserRuleCall_1_0_0; }

		//EOL
		public RuleCall getEOLTerminalRuleCall_1_1() { return cEOLTerminalRuleCall_1_1; }
	}

	public class ElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Element");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBytemanRuleParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cHelperParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Element:
		//	BytemanRule | Helper;
		public ParserRule getRule() { return rule; }

		//BytemanRule | Helper
		public Alternatives getAlternatives() { return cAlternatives; }

		//BytemanRule
		public RuleCall getBytemanRuleParserRuleCall_0() { return cBytemanRuleParserRuleCall_0; }

		//Helper
		public RuleCall getHelperParserRuleCall_1() { return cHelperParserRuleCall_1; }
	}

	public class BytemanRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BytemanRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSTART_RULETerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cEOLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cEventAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEventEventParserRuleCall_2_0 = (RuleCall)cEventAssignment_2.eContents().get(0);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		private final RuleCall cEND_RULETerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final RuleCall cEOLTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//BytemanRule:
		//	name=START_RULE EOL* event=Event body=Body END_RULE EOL;
		public ParserRule getRule() { return rule; }

		//name=START_RULE EOL* event=Event body=Body END_RULE EOL
		public Group getGroup() { return cGroup; }

		//name=START_RULE
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//START_RULE
		public RuleCall getNameSTART_RULETerminalRuleCall_0_0() { return cNameSTART_RULETerminalRuleCall_0_0; }

		//EOL*
		public RuleCall getEOLTerminalRuleCall_1() { return cEOLTerminalRuleCall_1; }

		//event=Event
		public Assignment getEventAssignment_2() { return cEventAssignment_2; }

		//Event
		public RuleCall getEventEventParserRuleCall_2_0() { return cEventEventParserRuleCall_2_0; }

		//body=Body
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }

		//Body
		public RuleCall getBodyBodyParserRuleCall_3_0() { return cBodyBodyParserRuleCall_3_0; }

		//END_RULE
		public RuleCall getEND_RULETerminalRuleCall_4() { return cEND_RULETerminalRuleCall_4; }

		//EOL
		public RuleCall getEOLTerminalRuleCall_5() { return cEOLTerminalRuleCall_5; }
	}

	public class BodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Body");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cBindAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cBindBindParserRuleCall_0_0 = (RuleCall)cBindAssignment_0.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionConditionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Assignment cActionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cActionsActionsParserRuleCall_2_0 = (RuleCall)cActionsAssignment_2.eContents().get(0);
		
		/// *
		// * the rule body is not line-oriented so we ignore EOL below this part
		// * / Body hidden(WS, BM_COMMENT, EOL):
		//	bind=Bind? condition=Condition actions=Actions;
		public ParserRule getRule() { return rule; }

		//bind=Bind? condition=Condition actions=Actions
		public Group getGroup() { return cGroup; }

		//bind=Bind?
		public Assignment getBindAssignment_0() { return cBindAssignment_0; }

		//Bind
		public RuleCall getBindBindParserRuleCall_0_0() { return cBindBindParserRuleCall_0_0; }

		//condition=Condition
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//Condition
		public RuleCall getConditionConditionParserRuleCall_1_0() { return cConditionConditionParserRuleCall_1_0; }

		//actions=Actions
		public Assignment getActionsAssignment_2() { return cActionsAssignment_2; }

		//Actions
		public RuleCall getActionsActionsParserRuleCall_2_0() { return cActionsActionsParserRuleCall_2_0; }
	}

	public class EventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Event");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cClassAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cClassEventClassParserRuleCall_0_0_0 = (RuleCall)cClassAssignment_0_0.eContents().get(0);
		private final Assignment cInterfaceAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cInterfaceEventInterfaceParserRuleCall_0_1_0 = (RuleCall)cInterfaceAssignment_0_1.eContents().get(0);
		private final RuleCall cEOLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cMethodAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMethodEventMethodParserRuleCall_2_0 = (RuleCall)cMethodAssignment_2.eContents().get(0);
		private final RuleCall cEOLTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cHelperAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cHelperHelperParserRuleCall_4_0_0 = (RuleCall)cHelperAssignment_4_0.eContents().get(0);
		private final RuleCall cEOLTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cLocationSpecAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cLocationSpecLocationSpecifierParserRuleCall_5_0_0 = (RuleCall)cLocationSpecAssignment_5_0.eContents().get(0);
		private final RuleCall cEOLTerminalRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		
		/// *
		//	Definition of the event
		// * / Event:
		//	(class=EventClass | interface=EventInterface) EOL* method=EventMethod EOL* (helper=Helper EOL*)?
		//	(locationSpec=LocationSpecifier EOL*)?;
		public ParserRule getRule() { return rule; }

		//(class=EventClass | interface=EventInterface) EOL* method=EventMethod EOL* (helper=Helper EOL*)?
		//(locationSpec=LocationSpecifier EOL*)?
		public Group getGroup() { return cGroup; }

		//class=EventClass | interface=EventInterface
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//class=EventClass
		public Assignment getClassAssignment_0_0() { return cClassAssignment_0_0; }

		//EventClass
		public RuleCall getClassEventClassParserRuleCall_0_0_0() { return cClassEventClassParserRuleCall_0_0_0; }

		//interface=EventInterface
		public Assignment getInterfaceAssignment_0_1() { return cInterfaceAssignment_0_1; }

		//EventInterface
		public RuleCall getInterfaceEventInterfaceParserRuleCall_0_1_0() { return cInterfaceEventInterfaceParserRuleCall_0_1_0; }

		//EOL*
		public RuleCall getEOLTerminalRuleCall_1() { return cEOLTerminalRuleCall_1; }

		//method=EventMethod
		public Assignment getMethodAssignment_2() { return cMethodAssignment_2; }

		//EventMethod
		public RuleCall getMethodEventMethodParserRuleCall_2_0() { return cMethodEventMethodParserRuleCall_2_0; }

		//EOL*
		public RuleCall getEOLTerminalRuleCall_3() { return cEOLTerminalRuleCall_3; }

		//(helper=Helper EOL*)?
		public Group getGroup_4() { return cGroup_4; }

		//helper=Helper
		public Assignment getHelperAssignment_4_0() { return cHelperAssignment_4_0; }

		//Helper
		public RuleCall getHelperHelperParserRuleCall_4_0_0() { return cHelperHelperParserRuleCall_4_0_0; }

		//EOL*
		public RuleCall getEOLTerminalRuleCall_4_1() { return cEOLTerminalRuleCall_4_1; }

		//(locationSpec=LocationSpecifier EOL*)?
		public Group getGroup_5() { return cGroup_5; }

		//locationSpec=LocationSpecifier
		public Assignment getLocationSpecAssignment_5_0() { return cLocationSpecAssignment_5_0; }

		//LocationSpecifier
		public RuleCall getLocationSpecLocationSpecifierParserRuleCall_5_0_0() { return cLocationSpecLocationSpecifierParserRuleCall_5_0_0; }

		//EOL*
		public RuleCall getEOLTerminalRuleCall_5_1() { return cEOLTerminalRuleCall_5_1; }
	}

	public class EventClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EventClass");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeywordAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeywordKEYWORD_CLASSTerminalRuleCall_0_0 = (RuleCall)cKeywordAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//EventClass:
		//	keyword=KEYWORD_CLASS name=QualifiedName;
		public ParserRule getRule() { return rule; }

		//keyword=KEYWORD_CLASS name=QualifiedName
		public Group getGroup() { return cGroup; }

		//keyword=KEYWORD_CLASS
		public Assignment getKeywordAssignment_0() { return cKeywordAssignment_0; }

		//KEYWORD_CLASS
		public RuleCall getKeywordKEYWORD_CLASSTerminalRuleCall_0_0() { return cKeywordKEYWORD_CLASSTerminalRuleCall_0_0; }

		//name=QualifiedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_1_0() { return cNameQualifiedNameParserRuleCall_1_0; }
	}

	public class EventInterfaceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EventInterface");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeywordAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeywordKEYWORD_INTERFACETerminalRuleCall_0_0 = (RuleCall)cKeywordAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//EventInterface:
		//	keyword=KEYWORD_INTERFACE name=QualifiedName;
		public ParserRule getRule() { return rule; }

		//keyword=KEYWORD_INTERFACE name=QualifiedName
		public Group getGroup() { return cGroup; }

		//keyword=KEYWORD_INTERFACE
		public Assignment getKeywordAssignment_0() { return cKeywordAssignment_0; }

		//KEYWORD_INTERFACE
		public RuleCall getKeywordKEYWORD_INTERFACETerminalRuleCall_0_0() { return cKeywordKEYWORD_INTERFACETerminalRuleCall_0_0; }

		//name=QualifiedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_1_0() { return cNameQualifiedNameParserRuleCall_1_0; }
	}

	public class EventMethodElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EventMethod");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cKEYWORD_METHODTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMethodNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cParameterTypesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParameterTypesParameterTypesParserRuleCall_2_0 = (RuleCall)cParameterTypesAssignment_2.eContents().get(0);
		
		//EventMethod:
		//	KEYWORD_METHOD name=MethodName parameterTypes=ParameterTypes?;
		public ParserRule getRule() { return rule; }

		//KEYWORD_METHOD name=MethodName parameterTypes=ParameterTypes?
		public Group getGroup() { return cGroup; }

		//KEYWORD_METHOD
		public RuleCall getKEYWORD_METHODTerminalRuleCall_0() { return cKEYWORD_METHODTerminalRuleCall_0; }

		//name=MethodName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MethodName
		public RuleCall getNameMethodNameParserRuleCall_1_0() { return cNameMethodNameParserRuleCall_1_0; }

		//parameterTypes=ParameterTypes?
		public Assignment getParameterTypesAssignment_2() { return cParameterTypesAssignment_2; }

		//ParameterTypes
		public RuleCall getParameterTypesParameterTypesParserRuleCall_2_0() { return cParameterTypesParameterTypesParserRuleCall_2_0; }
	}

	public class MethodNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MethodName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cINITTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCLINITTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//MethodName:
		//	ID | INIT | CLINIT;
		public ParserRule getRule() { return rule; }

		//ID | INIT | CLINIT
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//INIT
		public RuleCall getINITTerminalRuleCall_1() { return cINITTerminalRuleCall_1; }

		//CLINIT
		public RuleCall getCLINITTerminalRuleCall_2() { return cCLINITTerminalRuleCall_2; }
	}

	public class HelperElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Helper");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cHelperAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cHELPERKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cHelperAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cHelperQualifiedNameParserRuleCall_2_0 = (RuleCall)cHelperAssignment_2.eContents().get(0);
		
		//Helper:
		//	{Helper} "HELPER" helper=QualifiedName?;
		public ParserRule getRule() { return rule; }

		//{Helper} "HELPER" helper=QualifiedName?
		public Group getGroup() { return cGroup; }

		//{Helper}
		public Action getHelperAction_0() { return cHelperAction_0; }

		//"HELPER"
		public Keyword getHELPERKeyword_1() { return cHELPERKeyword_1; }

		//helper=QualifiedName?
		public Assignment getHelperAssignment_2() { return cHelperAssignment_2; }

		//QualifiedName
		public RuleCall getHelperQualifiedNameParserRuleCall_2_0() { return cHelperQualifiedNameParserRuleCall_2_0; }
	}

	public class LocationSpecifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocationSpecifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cATKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cAtLocationParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cAFTERKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cAfterLocationParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cAtLineParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//LocationSpecifier:
		//	"AT" AtLocation | "AFTER" AfterLocation | AtLine;
		public ParserRule getRule() { return rule; }

		//"AT" AtLocation | "AFTER" AfterLocation | AtLine
		public Alternatives getAlternatives() { return cAlternatives; }

		//"AT" AtLocation
		public Group getGroup_0() { return cGroup_0; }

		//"AT"
		public Keyword getATKeyword_0_0() { return cATKeyword_0_0; }

		//AtLocation
		public RuleCall getAtLocationParserRuleCall_0_1() { return cAtLocationParserRuleCall_0_1; }

		//"AFTER" AfterLocation
		public Group getGroup_1() { return cGroup_1; }

		//"AFTER"
		public Keyword getAFTERKeyword_1_0() { return cAFTERKeyword_1_0; }

		//AfterLocation
		public RuleCall getAfterLocationParserRuleCall_1_1() { return cAfterLocationParserRuleCall_1_1; }

		//AtLine
		public RuleCall getAtLineParserRuleCall_2() { return cAtLineParserRuleCall_2; }
	}

	public class AtLocationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtLocation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtEntryParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAtExitParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAtLineParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAtReadParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cAtWriteParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cAtInvokeParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cAtSynchronizeParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cAtThrowParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//AtLocation:
		//	AtEntry | AtExit | AtLine | AtRead | AtWrite | AtInvoke | AtSynchronize | AtThrow;
		public ParserRule getRule() { return rule; }

		//AtEntry | AtExit | AtLine | AtRead | AtWrite | AtInvoke | AtSynchronize | AtThrow
		public Alternatives getAlternatives() { return cAlternatives; }

		//AtEntry
		public RuleCall getAtEntryParserRuleCall_0() { return cAtEntryParserRuleCall_0; }

		//AtExit
		public RuleCall getAtExitParserRuleCall_1() { return cAtExitParserRuleCall_1; }

		//AtLine
		public RuleCall getAtLineParserRuleCall_2() { return cAtLineParserRuleCall_2; }

		//AtRead
		public RuleCall getAtReadParserRuleCall_3() { return cAtReadParserRuleCall_3; }

		//AtWrite
		public RuleCall getAtWriteParserRuleCall_4() { return cAtWriteParserRuleCall_4; }

		//AtInvoke
		public RuleCall getAtInvokeParserRuleCall_5() { return cAtInvokeParserRuleCall_5; }

		//AtSynchronize
		public RuleCall getAtSynchronizeParserRuleCall_6() { return cAtSynchronizeParserRuleCall_6; }

		//AtThrow
		public RuleCall getAtThrowParserRuleCall_7() { return cAtThrowParserRuleCall_7; }
	}

	public class AfterLocationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AfterLocation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAfterReadParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAfterWriteParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAfterInvokeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAfterSynchronizeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cAtThrowParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//AfterLocation:
		//	AfterRead | AfterWrite | AfterInvoke | AfterSynchronize | AtThrow;
		public ParserRule getRule() { return rule; }

		//AfterRead | AfterWrite | AfterInvoke | AfterSynchronize | AtThrow
		public Alternatives getAlternatives() { return cAlternatives; }

		//AfterRead
		public RuleCall getAfterReadParserRuleCall_0() { return cAfterReadParserRuleCall_0; }

		//AfterWrite
		public RuleCall getAfterWriteParserRuleCall_1() { return cAfterWriteParserRuleCall_1; }

		//AfterInvoke
		public RuleCall getAfterInvokeParserRuleCall_2() { return cAfterInvokeParserRuleCall_2; }

		//AfterSynchronize
		public RuleCall getAfterSynchronizeParserRuleCall_3() { return cAfterSynchronizeParserRuleCall_3; }

		//AtThrow
		public RuleCall getAtThrowParserRuleCall_4() { return cAtThrowParserRuleCall_4; }
	}

	public class AtEntryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtEntry");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtEntryAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cENTRYKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//AtEntry:
		//	{AtEntry} "ENTRY";
		public ParserRule getRule() { return rule; }

		//{AtEntry} "ENTRY"
		public Group getGroup() { return cGroup; }

		//{AtEntry}
		public Action getAtEntryAction_0() { return cAtEntryAction_0; }

		//"ENTRY"
		public Keyword getENTRYKeyword_1() { return cENTRYKeyword_1; }
	}

	public class AtExitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtExit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtExitAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cEXITKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final RuleCall cKEYWORD_RETURNTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//AtExit:
		//	{AtExit} ("EXIT" | KEYWORD_RETURN);
		public ParserRule getRule() { return rule; }

		//{AtExit} ("EXIT" | KEYWORD_RETURN)
		public Group getGroup() { return cGroup; }

		//{AtExit}
		public Action getAtExitAction_0() { return cAtExitAction_0; }

		//"EXIT" | KEYWORD_RETURN
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"EXIT"
		public Keyword getEXITKeyword_1_0() { return cEXITKeyword_1_0; }

		//KEYWORD_RETURN
		public RuleCall getKEYWORD_RETURNTerminalRuleCall_1_1() { return cKEYWORD_RETURNTerminalRuleCall_1_1; }
	}

	public class AtLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtLineAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLINEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLineAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLineINTVALTerminalRuleCall_2_0 = (RuleCall)cLineAssignment_2.eContents().get(0);
		
		//AtLine:
		//	{AtLine} "LINE" line=INTVAL;
		public ParserRule getRule() { return rule; }

		//{AtLine} "LINE" line=INTVAL
		public Group getGroup() { return cGroup; }

		//{AtLine}
		public Action getAtLineAction_0() { return cAtLineAction_0; }

		//"LINE"
		public Keyword getLINEKeyword_1() { return cLINEKeyword_1; }

		//line=INTVAL
		public Assignment getLineAssignment_2() { return cLineAssignment_2; }

		//INTVAL
		public RuleCall getLineINTVALTerminalRuleCall_2_0() { return cLineINTVALTerminalRuleCall_2_0; }
	}

	public class AtReadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtRead");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtReadFieldParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAtReadLocalParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AtRead:
		//	AtReadField | AtReadLocal;
		public ParserRule getRule() { return rule; }

		//AtReadField | AtReadLocal
		public Alternatives getAlternatives() { return cAlternatives; }

		//AtReadField
		public RuleCall getAtReadFieldParserRuleCall_0() { return cAtReadFieldParserRuleCall_0; }

		//AtReadLocal
		public RuleCall getAtReadLocalParserRuleCall_1() { return cAtReadLocalParserRuleCall_1; }
	}

	public class AtReadFieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtReadField");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtReadFieldAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cREADKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cCounterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCounterCounterParserRuleCall_3_0 = (RuleCall)cCounterAssignment_3.eContents().get(0);
		
		//AtReadField:
		//	{AtReadField} "READ" name=QualifiedName counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AtReadField} "READ" name=QualifiedName counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AtReadField}
		public Action getAtReadFieldAction_0() { return cAtReadFieldAction_0; }

		//"READ"
		public Keyword getREADKeyword_1() { return cREADKeyword_1; }

		//name=QualifiedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }

		//counter=Counter?
		public Assignment getCounterAssignment_3() { return cCounterAssignment_3; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_3_0() { return cCounterCounterParserRuleCall_3_0; }
	}

	public class AtReadLocalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtReadLocal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtReadLocalAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cREADKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cDOLLARTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cCounterAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCounterCounterParserRuleCall_4_0 = (RuleCall)cCounterAssignment_4.eContents().get(0);
		
		//AtReadLocal:
		//	{AtReadLocal} "READ" DOLLAR name=ID counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AtReadLocal} "READ" DOLLAR name=ID counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AtReadLocal}
		public Action getAtReadLocalAction_0() { return cAtReadLocalAction_0; }

		//"READ"
		public Keyword getREADKeyword_1() { return cREADKeyword_1; }

		//DOLLAR
		public RuleCall getDOLLARTerminalRuleCall_2() { return cDOLLARTerminalRuleCall_2; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//counter=Counter?
		public Assignment getCounterAssignment_4() { return cCounterAssignment_4; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_4_0() { return cCounterCounterParserRuleCall_4_0; }
	}

	public class AfterReadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AfterRead");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAfterReadFieldParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAfterReadLocalParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AfterRead:
		//	AfterReadField | AfterReadLocal;
		public ParserRule getRule() { return rule; }

		//AfterReadField | AfterReadLocal
		public Alternatives getAlternatives() { return cAlternatives; }

		//AfterReadField
		public RuleCall getAfterReadFieldParserRuleCall_0() { return cAfterReadFieldParserRuleCall_0; }

		//AfterReadLocal
		public RuleCall getAfterReadLocalParserRuleCall_1() { return cAfterReadLocalParserRuleCall_1; }
	}

	public class AfterReadFieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AfterReadField");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAfterReadFieldAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cREADKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cCounterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCounterCounterParserRuleCall_3_0 = (RuleCall)cCounterAssignment_3.eContents().get(0);
		
		//AfterReadField:
		//	{AfterReadField} "READ" name=QualifiedName counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AfterReadField} "READ" name=QualifiedName counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AfterReadField}
		public Action getAfterReadFieldAction_0() { return cAfterReadFieldAction_0; }

		//"READ"
		public Keyword getREADKeyword_1() { return cREADKeyword_1; }

		//name=QualifiedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }

		//counter=Counter?
		public Assignment getCounterAssignment_3() { return cCounterAssignment_3; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_3_0() { return cCounterCounterParserRuleCall_3_0; }
	}

	public class AfterReadLocalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AfterReadLocal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAfterReadLocalAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cREADKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cDOLLARTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cCounterAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCounterCounterParserRuleCall_4_0 = (RuleCall)cCounterAssignment_4.eContents().get(0);
		
		//AfterReadLocal:
		//	{AfterReadLocal} "READ" DOLLAR name=ID counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AfterReadLocal} "READ" DOLLAR name=ID counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AfterReadLocal}
		public Action getAfterReadLocalAction_0() { return cAfterReadLocalAction_0; }

		//"READ"
		public Keyword getREADKeyword_1() { return cREADKeyword_1; }

		//DOLLAR
		public RuleCall getDOLLARTerminalRuleCall_2() { return cDOLLARTerminalRuleCall_2; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//counter=Counter?
		public Assignment getCounterAssignment_4() { return cCounterAssignment_4; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_4_0() { return cCounterCounterParserRuleCall_4_0; }
	}

	public class AtWriteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtWrite");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtWriteFieldParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAtWriteLocalParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AtWrite:
		//	AtWriteField | AtWriteLocal;
		public ParserRule getRule() { return rule; }

		//AtWriteField | AtWriteLocal
		public Alternatives getAlternatives() { return cAlternatives; }

		//AtWriteField
		public RuleCall getAtWriteFieldParserRuleCall_0() { return cAtWriteFieldParserRuleCall_0; }

		//AtWriteLocal
		public RuleCall getAtWriteLocalParserRuleCall_1() { return cAtWriteLocalParserRuleCall_1; }
	}

	public class AtWriteFieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtWriteField");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtWriteFieldAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWRITEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cCounterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCounterCounterParserRuleCall_3_0 = (RuleCall)cCounterAssignment_3.eContents().get(0);
		
		//AtWriteField:
		//	{AtWriteField} "WRITE" name=QualifiedName counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AtWriteField} "WRITE" name=QualifiedName counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AtWriteField}
		public Action getAtWriteFieldAction_0() { return cAtWriteFieldAction_0; }

		//"WRITE"
		public Keyword getWRITEKeyword_1() { return cWRITEKeyword_1; }

		//name=QualifiedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }

		//counter=Counter?
		public Assignment getCounterAssignment_3() { return cCounterAssignment_3; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_3_0() { return cCounterCounterParserRuleCall_3_0; }
	}

	public class AtWriteLocalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtWriteLocal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtWriteLocalAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWRITEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cDOLLARTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cCounterAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCounterCounterParserRuleCall_4_0 = (RuleCall)cCounterAssignment_4.eContents().get(0);
		
		//AtWriteLocal:
		//	{AtWriteLocal} "WRITE" DOLLAR name=ID counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AtWriteLocal} "WRITE" DOLLAR name=ID counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AtWriteLocal}
		public Action getAtWriteLocalAction_0() { return cAtWriteLocalAction_0; }

		//"WRITE"
		public Keyword getWRITEKeyword_1() { return cWRITEKeyword_1; }

		//DOLLAR
		public RuleCall getDOLLARTerminalRuleCall_2() { return cDOLLARTerminalRuleCall_2; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//counter=Counter?
		public Assignment getCounterAssignment_4() { return cCounterAssignment_4; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_4_0() { return cCounterCounterParserRuleCall_4_0; }
	}

	public class AfterWriteElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AfterWrite");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAfterWriteFieldParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAfterWriteLocalParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AfterWrite:
		//	AfterWriteField | AfterWriteLocal;
		public ParserRule getRule() { return rule; }

		//AfterWriteField | AfterWriteLocal
		public Alternatives getAlternatives() { return cAlternatives; }

		//AfterWriteField
		public RuleCall getAfterWriteFieldParserRuleCall_0() { return cAfterWriteFieldParserRuleCall_0; }

		//AfterWriteLocal
		public RuleCall getAfterWriteLocalParserRuleCall_1() { return cAfterWriteLocalParserRuleCall_1; }
	}

	public class AfterWriteFieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AfterWriteField");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAfterWriteFieldAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWRITEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cCounterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCounterCounterParserRuleCall_3_0 = (RuleCall)cCounterAssignment_3.eContents().get(0);
		
		//AfterWriteField:
		//	{AfterWriteField} "WRITE" name=QualifiedName counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AfterWriteField} "WRITE" name=QualifiedName counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AfterWriteField}
		public Action getAfterWriteFieldAction_0() { return cAfterWriteFieldAction_0; }

		//"WRITE"
		public Keyword getWRITEKeyword_1() { return cWRITEKeyword_1; }

		//name=QualifiedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }

		//counter=Counter?
		public Assignment getCounterAssignment_3() { return cCounterAssignment_3; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_3_0() { return cCounterCounterParserRuleCall_3_0; }
	}

	public class AfterWriteLocalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AfterWriteLocal");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAfterWriteLocalAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWRITEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cDOLLARTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cCounterAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCounterCounterParserRuleCall_4_0 = (RuleCall)cCounterAssignment_4.eContents().get(0);
		
		//AfterWriteLocal:
		//	{AfterWriteLocal} "WRITE" DOLLAR name=ID counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AfterWriteLocal} "WRITE" DOLLAR name=ID counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AfterWriteLocal}
		public Action getAfterWriteLocalAction_0() { return cAfterWriteLocalAction_0; }

		//"WRITE"
		public Keyword getWRITEKeyword_1() { return cWRITEKeyword_1; }

		//DOLLAR
		public RuleCall getDOLLARTerminalRuleCall_2() { return cDOLLARTerminalRuleCall_2; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//counter=Counter?
		public Assignment getCounterAssignment_4() { return cCounterAssignment_4; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_4_0() { return cCounterCounterParserRuleCall_4_0; }
	}

	public class AtInvokeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtInvoke");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtInvokeAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cINVOKEKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cCALLKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cParameterTypesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParameterTypesParameterTypesParserRuleCall_3_0 = (RuleCall)cParameterTypesAssignment_3.eContents().get(0);
		private final Assignment cCounterAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCounterCounterParserRuleCall_4_0 = (RuleCall)cCounterAssignment_4.eContents().get(0);
		
		//AtInvoke:
		//	{AtInvoke} ("INVOKE" | "CALL") name=QualifiedName parameterTypes=ParameterTypes? counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AtInvoke} ("INVOKE" | "CALL") name=QualifiedName parameterTypes=ParameterTypes? counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AtInvoke}
		public Action getAtInvokeAction_0() { return cAtInvokeAction_0; }

		//"INVOKE" | "CALL"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"INVOKE"
		public Keyword getINVOKEKeyword_1_0() { return cINVOKEKeyword_1_0; }

		//"CALL"
		public Keyword getCALLKeyword_1_1() { return cCALLKeyword_1_1; }

		//name=QualifiedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }

		//parameterTypes=ParameterTypes?
		public Assignment getParameterTypesAssignment_3() { return cParameterTypesAssignment_3; }

		//ParameterTypes
		public RuleCall getParameterTypesParameterTypesParserRuleCall_3_0() { return cParameterTypesParameterTypesParserRuleCall_3_0; }

		//counter=Counter?
		public Assignment getCounterAssignment_4() { return cCounterAssignment_4; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_4_0() { return cCounterCounterParserRuleCall_4_0; }
	}

	public class AfterInvokeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AfterInvoke");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAfterInvokeAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cINVOKEKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cCALLKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cParameterTypesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParameterTypesParameterTypesParserRuleCall_3_0 = (RuleCall)cParameterTypesAssignment_3.eContents().get(0);
		private final Assignment cCounterAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCounterCounterParserRuleCall_4_0 = (RuleCall)cCounterAssignment_4.eContents().get(0);
		
		//AfterInvoke:
		//	{AfterInvoke} ("INVOKE" | "CALL") name=QualifiedName parameterTypes=ParameterTypes? counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AfterInvoke} ("INVOKE" | "CALL") name=QualifiedName parameterTypes=ParameterTypes? counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AfterInvoke}
		public Action getAfterInvokeAction_0() { return cAfterInvokeAction_0; }

		//"INVOKE" | "CALL"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"INVOKE"
		public Keyword getINVOKEKeyword_1_0() { return cINVOKEKeyword_1_0; }

		//"CALL"
		public Keyword getCALLKeyword_1_1() { return cCALLKeyword_1_1; }

		//name=QualifiedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }

		//parameterTypes=ParameterTypes?
		public Assignment getParameterTypesAssignment_3() { return cParameterTypesAssignment_3; }

		//ParameterTypes
		public RuleCall getParameterTypesParameterTypesParserRuleCall_3_0() { return cParameterTypesParameterTypesParserRuleCall_3_0; }

		//counter=Counter?
		public Assignment getCounterAssignment_4() { return cCounterAssignment_4; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_4_0() { return cCounterCounterParserRuleCall_4_0; }
	}

	public class AtSynchronizeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtSynchronize");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtSynchronizeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSYNCHRONIZEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCounterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCounterCounterParserRuleCall_2_0 = (RuleCall)cCounterAssignment_2.eContents().get(0);
		
		//AtSynchronize:
		//	{AtSynchronize} "SYNCHRONIZE" counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AtSynchronize} "SYNCHRONIZE" counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AtSynchronize}
		public Action getAtSynchronizeAction_0() { return cAtSynchronizeAction_0; }

		//"SYNCHRONIZE"
		public Keyword getSYNCHRONIZEKeyword_1() { return cSYNCHRONIZEKeyword_1; }

		//counter=Counter?
		public Assignment getCounterAssignment_2() { return cCounterAssignment_2; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_2_0() { return cCounterCounterParserRuleCall_2_0; }
	}

	public class AfterSynchronizeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AfterSynchronize");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAfterSynchronizeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSYNCHRONIZEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCounterAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCounterCounterParserRuleCall_2_0 = (RuleCall)cCounterAssignment_2.eContents().get(0);
		
		//AfterSynchronize:
		//	{AfterSynchronize} "SYNCHRONIZE" counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AfterSynchronize} "SYNCHRONIZE" counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AfterSynchronize}
		public Action getAfterSynchronizeAction_0() { return cAfterSynchronizeAction_0; }

		//"SYNCHRONIZE"
		public Keyword getSYNCHRONIZEKeyword_1() { return cSYNCHRONIZEKeyword_1; }

		//counter=Counter?
		public Assignment getCounterAssignment_2() { return cCounterAssignment_2; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_2_0() { return cCounterCounterParserRuleCall_2_0; }
	}

	public class AtThrowElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtThrow");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtThrowAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTHROWKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameQualifiedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cCounterAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCounterCounterParserRuleCall_3_0 = (RuleCall)cCounterAssignment_3.eContents().get(0);
		
		//AtThrow:
		//	{AtThrow} "THROW" name=QualifiedName? counter=Counter?;
		public ParserRule getRule() { return rule; }

		//{AtThrow} "THROW" name=QualifiedName? counter=Counter?
		public Group getGroup() { return cGroup; }

		//{AtThrow}
		public Action getAtThrowAction_0() { return cAtThrowAction_0; }

		//"THROW"
		public Keyword getTHROWKeyword_1() { return cTHROWKeyword_1; }

		//name=QualifiedName?
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_2_0() { return cNameQualifiedNameParserRuleCall_2_0; }

		//counter=Counter?
		public Assignment getCounterAssignment_3() { return cCounterAssignment_3; }

		//Counter
		public RuleCall getCounterCounterParserRuleCall_3_0() { return cCounterCounterParserRuleCall_3_0; }
	}

	public class ParameterTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParameterTypes");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLPARENTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cParameterTypesAction_1 = (Action)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParamTypeNamesAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParamTypeNamesParamTypeNameParserRuleCall_2_0_0 = (RuleCall)cParamTypeNamesAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final RuleCall cCOMMATerminalRuleCall_2_1_0 = (RuleCall)cGroup_2_1.eContents().get(0);
		private final Assignment cParamTypeNamesAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParamTypeNamesParamTypeNameParserRuleCall_2_1_1_0 = (RuleCall)cParamTypeNamesAssignment_2_1_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//ParameterTypes:
		//	LPAREN {ParameterTypes} (paramTypeNames+=ParamTypeName (COMMA paramTypeNames+=ParamTypeName)*)? RPAREN;
		public ParserRule getRule() { return rule; }

		//LPAREN {ParameterTypes} (paramTypeNames+=ParamTypeName (COMMA paramTypeNames+=ParamTypeName)*)? RPAREN
		public Group getGroup() { return cGroup; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_0() { return cLPARENTerminalRuleCall_0; }

		//{ParameterTypes}
		public Action getParameterTypesAction_1() { return cParameterTypesAction_1; }

		//(paramTypeNames+=ParamTypeName (COMMA paramTypeNames+=ParamTypeName)*)?
		public Group getGroup_2() { return cGroup_2; }

		//paramTypeNames+=ParamTypeName
		public Assignment getParamTypeNamesAssignment_2_0() { return cParamTypeNamesAssignment_2_0; }

		//ParamTypeName
		public RuleCall getParamTypeNamesParamTypeNameParserRuleCall_2_0_0() { return cParamTypeNamesParamTypeNameParserRuleCall_2_0_0; }

		//(COMMA paramTypeNames+=ParamTypeName)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_2_1_0() { return cCOMMATerminalRuleCall_2_1_0; }

		//paramTypeNames+=ParamTypeName
		public Assignment getParamTypeNamesAssignment_2_1_1() { return cParamTypeNamesAssignment_2_1_1; }

		//ParamTypeName
		public RuleCall getParamTypeNamesParamTypeNameParserRuleCall_2_1_1_0() { return cParamTypeNamesParamTypeNameParserRuleCall_2_1_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3() { return cRPARENTerminalRuleCall_3; }
	}

	public class ParamTypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParamTypeName");
		private final RuleCall cQualifiedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ParamTypeName:
		//	QualifiedName;
		public ParserRule getRule() { return rule; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall() { return cQualifiedNameParserRuleCall; }
	}

	public class CounterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Counter");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTVALTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cALLKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//Counter:
		//	INTVAL | "ALL";
		public ParserRule getRule() { return rule; }

		//INTVAL | "ALL"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INTVAL
		public RuleCall getINTVALTerminalRuleCall_0() { return cINTVALTerminalRuleCall_0; }

		//"ALL"
		public Keyword getALLKeyword_1() { return cALLKeyword_1; }
	}

	public class BindElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bind");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cKEYWORD_BINDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cBindAction_1 = (Action)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final RuleCall cNOTHINGTerminalRuleCall_2_0 = (RuleCall)cAlternatives_2.eContents().get(0);
		private final Assignment cBindAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cBindBindingsParserRuleCall_2_1_0 = (RuleCall)cBindAssignment_2_1.eContents().get(0);
		
		//Bind:
		//	KEYWORD_BIND {Bind} (NOTHING | bind=Bindings);
		public ParserRule getRule() { return rule; }

		//KEYWORD_BIND {Bind} (NOTHING | bind=Bindings)
		public Group getGroup() { return cGroup; }

		//KEYWORD_BIND
		public RuleCall getKEYWORD_BINDTerminalRuleCall_0() { return cKEYWORD_BINDTerminalRuleCall_0; }

		//{Bind}
		public Action getBindAction_1() { return cBindAction_1; }

		//NOTHING | bind=Bindings
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//NOTHING
		public RuleCall getNOTHINGTerminalRuleCall_2_0() { return cNOTHINGTerminalRuleCall_2_0; }

		//bind=Bindings
		public Assignment getBindAssignment_2_1() { return cBindAssignment_2_1; }

		//Bindings
		public RuleCall getBindBindingsParserRuleCall_2_1_0() { return cBindBindingsParserRuleCall_2_1_0; }
	}

	public class BindingsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bindings");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cBindingsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cBindingsBindingParserRuleCall_0_0 = (RuleCall)cBindingsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cSEMICOLONTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cBindingsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cBindingsBindingParserRuleCall_1_1_0 = (RuleCall)cBindingsAssignment_1_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Bindings:
		//	bindings+=Binding (SEMICOLON bindings+=Binding)* SEMICOLON?;
		public ParserRule getRule() { return rule; }

		//bindings+=Binding (SEMICOLON bindings+=Binding)* SEMICOLON?
		public Group getGroup() { return cGroup; }

		//bindings+=Binding
		public Assignment getBindingsAssignment_0() { return cBindingsAssignment_0; }

		//Binding
		public RuleCall getBindingsBindingParserRuleCall_0_0() { return cBindingsBindingParserRuleCall_0_0; }

		//(SEMICOLON bindings+=Binding)*
		public Group getGroup_1() { return cGroup_1; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_1_0() { return cSEMICOLONTerminalRuleCall_1_0; }

		//bindings+=Binding
		public Assignment getBindingsAssignment_1_1() { return cBindingsAssignment_1_1; }

		//Binding
		public RuleCall getBindingsBindingParserRuleCall_1_1_0() { return cBindingsBindingParserRuleCall_1_1_0; }

		//SEMICOLON?
		public RuleCall getSEMICOLONTerminalRuleCall_2() { return cSEMICOLONTerminalRuleCall_2; }
	}

	public class BindingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Binding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cBindVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cBindVariableBindVariableParserRuleCall_0_0 = (RuleCall)cBindVariableAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final RuleCall cASSIGNTerminalRuleCall_1_0_0 = (RuleCall)cGroup_1_0.eContents().get(0);
		private final Assignment cValueAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_0_1_0 = (RuleCall)cValueAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Group cGroup_1_1_0 = (Group)cGroup_1_1.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_1_1_0_0 = (RuleCall)cGroup_1_1_0.eContents().get(0);
		private final Assignment cTypenameAssignment_1_1_0_1 = (Assignment)cGroup_1_1_0.eContents().get(1);
		private final RuleCall cTypenameTypeNameParserRuleCall_1_1_0_1_0 = (RuleCall)cTypenameAssignment_1_1_0_1.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final RuleCall cASSIGNTerminalRuleCall_1_1_1_0 = (RuleCall)cGroup_1_1_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_1_1_1_0 = (RuleCall)cValueAssignment_1_1_1_1.eContents().get(0);
		
		//Binding:
		//	bindVariable= // assignment is optional but only if we have a type
		//	BindVariable (ASSIGN value=Expression | (COLON typename=TypeName) (ASSIGN value=Expression)?);
		public ParserRule getRule() { return rule; }

		//bindVariable= // assignment is optional but only if we have a type
		//BindVariable (ASSIGN value=Expression | (COLON typename=TypeName) (ASSIGN value=Expression)?)
		public Group getGroup() { return cGroup; }

		//bindVariable= // assignment is optional but only if we have a type
		//BindVariable
		public Assignment getBindVariableAssignment_0() { return cBindVariableAssignment_0; }

		//// assignment is optional but only if we have a type
		//BindVariable
		public RuleCall getBindVariableBindVariableParserRuleCall_0_0() { return cBindVariableBindVariableParserRuleCall_0_0; }

		//ASSIGN value=Expression | (COLON typename=TypeName) (ASSIGN value=Expression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//ASSIGN value=Expression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//ASSIGN
		public RuleCall getASSIGNTerminalRuleCall_1_0_0() { return cASSIGNTerminalRuleCall_1_0_0; }

		//value=Expression
		public Assignment getValueAssignment_1_0_1() { return cValueAssignment_1_0_1; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_0_1_0() { return cValueExpressionParserRuleCall_1_0_1_0; }

		//(COLON typename=TypeName) (ASSIGN value=Expression)?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//COLON typename=TypeName
		public Group getGroup_1_1_0() { return cGroup_1_1_0; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_1_1_0_0() { return cCOLONTerminalRuleCall_1_1_0_0; }

		//typename=TypeName
		public Assignment getTypenameAssignment_1_1_0_1() { return cTypenameAssignment_1_1_0_1; }

		//TypeName
		public RuleCall getTypenameTypeNameParserRuleCall_1_1_0_1_0() { return cTypenameTypeNameParserRuleCall_1_1_0_1_0; }

		//(ASSIGN value=Expression)?
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//ASSIGN
		public RuleCall getASSIGNTerminalRuleCall_1_1_1_0() { return cASSIGNTerminalRuleCall_1_1_1_0; }

		//value=Expression
		public Assignment getValueAssignment_1_1_1_1() { return cValueAssignment_1_1_1_1; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_1_1_1_0() { return cValueExpressionParserRuleCall_1_1_1_1_0; }
	}

	public class BindVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BindVariable");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//BindVariable:
		//	ID;
		public ParserRule getRule() { return rule; }

		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}

	public class TypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeName");
		private final RuleCall cQualifiedNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//TypeName:
		//	QualifiedName;
		public ParserRule getRule() { return rule; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall() { return cQualifiedNameParserRuleCall; }
	}

	public class ConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Condition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIFTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		/// *
		// * Definition of the Condition
		// * / Condition:
		//	IF Expression;
		public ParserRule getRule() { return rule; }

		//IF Expression
		public Group getGroup() { return cGroup; }

		//IF
		public RuleCall getIFTerminalRuleCall_0() { return cIFTerminalRuleCall_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
	}

	public class ActionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Actions");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cActionsAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cDOTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cActionListAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cActionListActionListParserRuleCall_2_0_0 = (RuleCall)cActionListAssignment_2_0.eContents().get(0);
		private final RuleCall cNOTHINGTerminalRuleCall_2_1 = (RuleCall)cAlternatives_2.eContents().get(1);
		
		/// *
		// * Definition of action
		// * / Actions:
		//	{Actions} DO (actionList=ActionList | NOTHING);
		public ParserRule getRule() { return rule; }

		//{Actions} DO (actionList=ActionList | NOTHING)
		public Group getGroup() { return cGroup; }

		//{Actions}
		public Action getActionsAction_0() { return cActionsAction_0; }

		//DO
		public RuleCall getDOTerminalRuleCall_1() { return cDOTerminalRuleCall_1; }

		//actionList=ActionList | NOTHING
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//actionList=ActionList
		public Assignment getActionListAssignment_2_0() { return cActionListAssignment_2_0; }

		//ActionList
		public RuleCall getActionListActionListParserRuleCall_2_0_0() { return cActionListActionListParserRuleCall_2_0_0; }

		//NOTHING
		public RuleCall getNOTHINGTerminalRuleCall_2_1() { return cNOTHINGTerminalRuleCall_2_1; }
	}

	public class ActionListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ActionList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cActionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cActionsActionParserRuleCall_0_0 = (RuleCall)cActionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cSEMICOLONTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cActionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cActionsActionParserRuleCall_1_1_0 = (RuleCall)cActionsAssignment_1_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//ActionList:
		//	actions+=Action (SEMICOLON actions+=Action)* SEMICOLON?;
		public ParserRule getRule() { return rule; }

		//actions+=Action (SEMICOLON actions+=Action)* SEMICOLON?
		public Group getGroup() { return cGroup; }

		//actions+=Action
		public Assignment getActionsAssignment_0() { return cActionsAssignment_0; }

		//Action
		public RuleCall getActionsActionParserRuleCall_0_0() { return cActionsActionParserRuleCall_0_0; }

		//(SEMICOLON actions+=Action)*
		public Group getGroup_1() { return cGroup_1; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_1_0() { return cSEMICOLONTerminalRuleCall_1_0; }

		//actions+=Action
		public Assignment getActionsAssignment_1_1() { return cActionsAssignment_1_1; }

		//Action
		public RuleCall getActionsActionParserRuleCall_1_1_0() { return cActionsActionParserRuleCall_1_1_0; }

		//SEMICOLON?
		public RuleCall getSEMICOLONTerminalRuleCall_2() { return cSEMICOLONTerminalRuleCall_2; }
	}

	public class ActionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Action");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cReturnExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cThrowExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// we really only want RETURN or THROW at the end of the list but try
		//// doing that without left recursion!
		//Action:
		//	Expression | ReturnExpr | ThrowExpr;
		public ParserRule getRule() { return rule; }

		//Expression | ReturnExpr | ThrowExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//ReturnExpr
		public RuleCall getReturnExprParserRuleCall_1() { return cReturnExprParserRuleCall_1; }

		//ThrowExpr
		public RuleCall getThrowExprParserRuleCall_2() { return cThrowExprParserRuleCall_2; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cAssignmentExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// assigments ned to be composable just as any other operator expression
		//// but the LHS should only be an AccessExpr and not a constant expr
		//// enforcing the former requires left recursion -- or maybe backtracking?
		//// enforcing the latter maybe also requires backtracking? anyway we can
		//// just make assigment the weakest binding operator and do a post check
		//// to ensure the LSH of an assign is of the right type
		//Expression:
		//	AssignmentExpr;
		public ParserRule getRule() { return rule; }

		//AssignmentExpr
		public RuleCall getAssignmentExprParserRuleCall() { return cAssignmentExprParserRuleCall; }
	}

	public class ReturnExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpKEYWORD_RETURNTerminalRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cOperand1Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperand1ExpressionParserRuleCall_1_0 = (RuleCall)cOperand1Assignment_1.eContents().get(0);
		
		//ReturnExpr returns Expression:
		//	op=KEYWORD_RETURN operand1=Expression?;
		public ParserRule getRule() { return rule; }

		//op=KEYWORD_RETURN operand1=Expression?
		public Group getGroup() { return cGroup; }

		//op=KEYWORD_RETURN
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }

		//KEYWORD_RETURN
		public RuleCall getOpKEYWORD_RETURNTerminalRuleCall_0_0() { return cOpKEYWORD_RETURNTerminalRuleCall_0_0; }

		//operand1=Expression?
		public Assignment getOperand1Assignment_1() { return cOperand1Assignment_1; }

		//Expression
		public RuleCall getOperand1ExpressionParserRuleCall_1_0() { return cOperand1ExpressionParserRuleCall_1_0; }
	}

	public class ThrowExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ThrowExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpKEYWORD_THROWTerminalRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cOperand1Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperand1ExpressionParserRuleCall_1_0 = (RuleCall)cOperand1Assignment_1.eContents().get(0);
		
		//ThrowExpr returns Expression:
		//	op=KEYWORD_THROW operand1=Expression;
		public ParserRule getRule() { return rule; }

		//op=KEYWORD_THROW operand1=Expression
		public Group getGroup() { return cGroup; }

		//op=KEYWORD_THROW
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }

		//KEYWORD_THROW
		public RuleCall getOpKEYWORD_THROWTerminalRuleCall_0_0() { return cOpKEYWORD_THROWTerminalRuleCall_0_0; }

		//operand1=Expression
		public Assignment getOperand1Assignment_1() { return cOperand1Assignment_1; }

		//Expression
		public RuleCall getOperand1ExpressionParserRuleCall_1_0() { return cOperand1ExpressionParserRuleCall_1_0; }
	}

	public class AssignmentExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOperatorExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAssignmentExprOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpASSIGNTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2AssignmentExprParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		/// *
		// * Definiton of Java expressions
		// * / // assignments have an LHS restricted to the different types of var
		//// expression and to fields and arrays. we have to allow access expressions
		//// and then typecheck out assignments to method members accesses, literals
		//// etc 
		//AssignmentExpr returns Expression:
		//	OperatorExpr ({AssignmentExpr.operand1=current} op=ASSIGN operand2=AssignmentExpr)?;
		public ParserRule getRule() { return rule; }

		//OperatorExpr ({AssignmentExpr.operand1=current} op=ASSIGN operand2=AssignmentExpr)?
		public Group getGroup() { return cGroup; }

		//OperatorExpr
		public RuleCall getOperatorExprParserRuleCall_0() { return cOperatorExprParserRuleCall_0; }

		//({AssignmentExpr.operand1=current} op=ASSIGN operand2=AssignmentExpr)?
		public Group getGroup_1() { return cGroup_1; }

		//{AssignmentExpr.operand1=current}
		public Action getAssignmentExprOperand1Action_1_0() { return cAssignmentExprOperand1Action_1_0; }

		//op=ASSIGN
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//ASSIGN
		public RuleCall getOpASSIGNTerminalRuleCall_1_1_0() { return cOpASSIGNTerminalRuleCall_1_1_0; }

		//operand2=AssignmentExpr
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//AssignmentExpr
		public RuleCall getOperand2AssignmentExprParserRuleCall_1_2_0() { return cOperand2AssignmentExprParserRuleCall_1_2_0; }
	}

	public class OperatorExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OperatorExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusMinusOperandParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperatorExprOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final RuleCall cOpPLUSTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(0);
		private final RuleCall cOpMINUSTerminalRuleCall_1_1_0_1 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2PlusMinusOperandParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		//// other expressions are composed from either simple expressions or
		//// expressions involving member or array accesses using either unary
		//// or binary operators. a hierarchy of rules is used to ensure that
		//// operator precedence is respected. tighter binding operators appear
		//// lower down the hierarchy.
		//OperatorExpr returns Expression:
		//	PlusMinusOperand ({OperatorExpr.operand1=current} op=(PLUS | MINUS) operand2=PlusMinusOperand)*;
		public ParserRule getRule() { return rule; }

		//PlusMinusOperand ({OperatorExpr.operand1=current} op=(PLUS | MINUS) operand2=PlusMinusOperand)*
		public Group getGroup() { return cGroup; }

		//PlusMinusOperand
		public RuleCall getPlusMinusOperandParserRuleCall_0() { return cPlusMinusOperandParserRuleCall_0; }

		//({OperatorExpr.operand1=current} op=(PLUS | MINUS) operand2=PlusMinusOperand)*
		public Group getGroup_1() { return cGroup_1; }

		//{OperatorExpr.operand1=current}
		public Action getOperatorExprOperand1Action_1_0() { return cOperatorExprOperand1Action_1_0; }

		//op=(PLUS | MINUS)
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//PLUS | MINUS
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//PLUS
		public RuleCall getOpPLUSTerminalRuleCall_1_1_0_0() { return cOpPLUSTerminalRuleCall_1_1_0_0; }

		//MINUS
		public RuleCall getOpMINUSTerminalRuleCall_1_1_0_1() { return cOpMINUSTerminalRuleCall_1_1_0_1; }

		//operand2=PlusMinusOperand
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//PlusMinusOperand
		public RuleCall getOperand2PlusMinusOperandParserRuleCall_1_2_0() { return cOperand2PlusMinusOperandParserRuleCall_1_2_0; }
	}

	public class PlusMinusOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PlusMinusOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTimesDivOperandParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPlusMinusOperandOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final RuleCall cOpTIMESTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(0);
		private final RuleCall cOpDIVTerminalRuleCall_1_1_0_1 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(1);
		private final RuleCall cOpMODTerminalRuleCall_1_1_0_2 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(2);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2TimesDivOperandParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		//PlusMinusOperand returns Expression:
		//	TimesDivOperand ({PlusMinusOperand.operand1=current} op=(TIMES | DIV | MOD) operand2=TimesDivOperand)*;
		public ParserRule getRule() { return rule; }

		//TimesDivOperand ({PlusMinusOperand.operand1=current} op=(TIMES | DIV | MOD) operand2=TimesDivOperand)*
		public Group getGroup() { return cGroup; }

		//TimesDivOperand
		public RuleCall getTimesDivOperandParserRuleCall_0() { return cTimesDivOperandParserRuleCall_0; }

		//({PlusMinusOperand.operand1=current} op=(TIMES | DIV | MOD) operand2=TimesDivOperand)*
		public Group getGroup_1() { return cGroup_1; }

		//{PlusMinusOperand.operand1=current}
		public Action getPlusMinusOperandOperand1Action_1_0() { return cPlusMinusOperandOperand1Action_1_0; }

		//op=(TIMES | DIV | MOD)
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//TIMES | DIV | MOD
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//TIMES
		public RuleCall getOpTIMESTerminalRuleCall_1_1_0_0() { return cOpTIMESTerminalRuleCall_1_1_0_0; }

		//DIV
		public RuleCall getOpDIVTerminalRuleCall_1_1_0_1() { return cOpDIVTerminalRuleCall_1_1_0_1; }

		//MOD
		public RuleCall getOpMODTerminalRuleCall_1_1_0_2() { return cOpMODTerminalRuleCall_1_1_0_2; }

		//operand2=TimesDivOperand
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//TimesDivOperand
		public RuleCall getOperand2TimesDivOperandParserRuleCall_1_2_0() { return cOperand2TimesDivOperandParserRuleCall_1_2_0; }
	}

	public class TimesDivOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TimesDivOperand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cBitwiseOperandParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Action cTimesDivOperandOperand1Action_0_1_0 = (Action)cGroup_0_1.eContents().get(0);
		private final Assignment cOpAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final Alternatives cOpAlternatives_0_1_1_0 = (Alternatives)cOpAssignment_0_1_1.eContents().get(0);
		private final RuleCall cOpBANDTerminalRuleCall_0_1_1_0_0 = (RuleCall)cOpAlternatives_0_1_1_0.eContents().get(0);
		private final RuleCall cOpBORTerminalRuleCall_0_1_1_0_1 = (RuleCall)cOpAlternatives_0_1_1_0.eContents().get(1);
		private final RuleCall cOpBXORTerminalRuleCall_0_1_1_0_2 = (RuleCall)cOpAlternatives_0_1_1_0.eContents().get(2);
		private final Assignment cOperand2Assignment_0_1_2 = (Assignment)cGroup_0_1.eContents().get(2);
		private final RuleCall cOperand2BitwiseOperandParserRuleCall_0_1_2_0 = (RuleCall)cOperand2Assignment_0_1_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cOpAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOpBNOTTerminalRuleCall_1_0_0 = (RuleCall)cOpAssignment_1_0.eContents().get(0);
		private final Assignment cOperand1Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperand1BitwiseOperandParserRuleCall_1_1_0 = (RuleCall)cOperand1Assignment_1_1.eContents().get(0);
		
		//TimesDivOperand returns Expression:
		//	BitwiseOperand ({TimesDivOperand.operand1=current} op=(BAND | BOR | BXOR) operand2=BitwiseOperand)* | op=BNOT
		//	operand1=BitwiseOperand;
		public ParserRule getRule() { return rule; }

		//BitwiseOperand ({TimesDivOperand.operand1=current} op=(BAND | BOR | BXOR) operand2=BitwiseOperand)* | op=BNOT
		//operand1=BitwiseOperand
		public Alternatives getAlternatives() { return cAlternatives; }

		//BitwiseOperand ({TimesDivOperand.operand1=current} op=(BAND | BOR | BXOR) operand2=BitwiseOperand)*
		public Group getGroup_0() { return cGroup_0; }

		//BitwiseOperand
		public RuleCall getBitwiseOperandParserRuleCall_0_0() { return cBitwiseOperandParserRuleCall_0_0; }

		//({TimesDivOperand.operand1=current} op=(BAND | BOR | BXOR) operand2=BitwiseOperand)*
		public Group getGroup_0_1() { return cGroup_0_1; }

		//{TimesDivOperand.operand1=current}
		public Action getTimesDivOperandOperand1Action_0_1_0() { return cTimesDivOperandOperand1Action_0_1_0; }

		//op=(BAND | BOR | BXOR)
		public Assignment getOpAssignment_0_1_1() { return cOpAssignment_0_1_1; }

		//BAND | BOR | BXOR
		public Alternatives getOpAlternatives_0_1_1_0() { return cOpAlternatives_0_1_1_0; }

		//BAND
		public RuleCall getOpBANDTerminalRuleCall_0_1_1_0_0() { return cOpBANDTerminalRuleCall_0_1_1_0_0; }

		//BOR
		public RuleCall getOpBORTerminalRuleCall_0_1_1_0_1() { return cOpBORTerminalRuleCall_0_1_1_0_1; }

		//BXOR
		public RuleCall getOpBXORTerminalRuleCall_0_1_1_0_2() { return cOpBXORTerminalRuleCall_0_1_1_0_2; }

		//operand2=BitwiseOperand
		public Assignment getOperand2Assignment_0_1_2() { return cOperand2Assignment_0_1_2; }

		//BitwiseOperand
		public RuleCall getOperand2BitwiseOperandParserRuleCall_0_1_2_0() { return cOperand2BitwiseOperandParserRuleCall_0_1_2_0; }

		//op=BNOT operand1=BitwiseOperand
		public Group getGroup_1() { return cGroup_1; }

		//op=BNOT
		public Assignment getOpAssignment_1_0() { return cOpAssignment_1_0; }

		//BNOT
		public RuleCall getOpBNOTTerminalRuleCall_1_0_0() { return cOpBNOTTerminalRuleCall_1_0_0; }

		//operand1=BitwiseOperand
		public Assignment getOperand1Assignment_1_1() { return cOperand1Assignment_1_1; }

		//BitwiseOperand
		public RuleCall getOperand1BitwiseOperandParserRuleCall_1_1_0() { return cOperand1BitwiseOperandParserRuleCall_1_1_0; }
	}

	public class BitwiseOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitwiseOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cLogicalOperandParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cNotOperandParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBitwiseOperandOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final RuleCall cOpORTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(0);
		private final RuleCall cOpANDTerminalRuleCall_1_1_0_1 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Alternatives cOperand2Alternatives_1_2_0 = (Alternatives)cOperand2Assignment_1_2.eContents().get(0);
		private final RuleCall cOperand2NotOperandParserRuleCall_1_2_0_0 = (RuleCall)cOperand2Alternatives_1_2_0.eContents().get(0);
		private final RuleCall cOperand2LogicalOperandParserRuleCall_1_2_0_1 = (RuleCall)cOperand2Alternatives_1_2_0.eContents().get(1);
		
		//BitwiseOperand returns Expression:
		//	(LogicalOperand | NotOperand) ({BitwiseOperand.operand1=current} op=(OR | AND) operand2=(NotOperand |
		//	LogicalOperand))*;
		public ParserRule getRule() { return rule; }

		//(LogicalOperand | NotOperand) ({BitwiseOperand.operand1=current} op=(OR | AND) operand2=(NotOperand | LogicalOperand))*
		public Group getGroup() { return cGroup; }

		//LogicalOperand | NotOperand
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//LogicalOperand
		public RuleCall getLogicalOperandParserRuleCall_0_0() { return cLogicalOperandParserRuleCall_0_0; }

		//NotOperand
		public RuleCall getNotOperandParserRuleCall_0_1() { return cNotOperandParserRuleCall_0_1; }

		//({BitwiseOperand.operand1=current} op=(OR | AND) operand2=(NotOperand | LogicalOperand))*
		public Group getGroup_1() { return cGroup_1; }

		//{BitwiseOperand.operand1=current}
		public Action getBitwiseOperandOperand1Action_1_0() { return cBitwiseOperandOperand1Action_1_0; }

		//op=(OR | AND)
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//OR | AND
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//OR
		public RuleCall getOpORTerminalRuleCall_1_1_0_0() { return cOpORTerminalRuleCall_1_1_0_0; }

		//AND
		public RuleCall getOpANDTerminalRuleCall_1_1_0_1() { return cOpANDTerminalRuleCall_1_1_0_1; }

		//operand2=(NotOperand | LogicalOperand)
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//NotOperand | LogicalOperand
		public Alternatives getOperand2Alternatives_1_2_0() { return cOperand2Alternatives_1_2_0; }

		//NotOperand
		public RuleCall getOperand2NotOperandParserRuleCall_1_2_0_0() { return cOperand2NotOperandParserRuleCall_1_2_0_0; }

		//LogicalOperand
		public RuleCall getOperand2LogicalOperandParserRuleCall_1_2_0_1() { return cOperand2LogicalOperandParserRuleCall_1_2_0_1; }
	}

	public class NotOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpNOTTerminalRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Assignment cOperand1Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperand1LogicalOperandParserRuleCall_1_0 = (RuleCall)cOperand1Assignment_1.eContents().get(0);
		
		//NotOperand returns Expression:
		//	op=NOT operand1=LogicalOperand;
		public ParserRule getRule() { return rule; }

		//op=NOT operand1=LogicalOperand
		public Group getGroup() { return cGroup; }

		//op=NOT
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }

		//NOT
		public RuleCall getOpNOTTerminalRuleCall_0_0() { return cOpNOTTerminalRuleCall_0_0; }

		//operand1=LogicalOperand
		public Assignment getOperand1Assignment_1() { return cOperand1Assignment_1; }

		//LogicalOperand
		public RuleCall getOperand1LogicalOperandParserRuleCall_1_0() { return cOperand1LogicalOperandParserRuleCall_1_0; }
	}

	public class LogicalOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOperand");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonOperandParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalOperandOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final RuleCall cOpEQTerminalRuleCall_1_1_0_0 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(0);
		private final RuleCall cOpGTTerminalRuleCall_1_1_0_1 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(1);
		private final RuleCall cOpGETerminalRuleCall_1_1_0_2 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(2);
		private final RuleCall cOpLETerminalRuleCall_1_1_0_3 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(3);
		private final RuleCall cOpLTTerminalRuleCall_1_1_0_4 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(4);
		private final RuleCall cOpNETerminalRuleCall_1_1_0_5 = (RuleCall)cOpAlternatives_1_1_0.eContents().get(5);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2ComparisonOperandParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		//LogicalOperand returns Expression:
		//	ComparisonOperand ({LogicalOperand.operand1=current} op=(EQ | GT | GE | LE | LT | NE) operand2=ComparisonOperand)*;
		public ParserRule getRule() { return rule; }

		//ComparisonOperand ({LogicalOperand.operand1=current} op=(EQ | GT | GE | LE | LT | NE) operand2=ComparisonOperand)*
		public Group getGroup() { return cGroup; }

		//ComparisonOperand
		public RuleCall getComparisonOperandParserRuleCall_0() { return cComparisonOperandParserRuleCall_0; }

		//({LogicalOperand.operand1=current} op=(EQ | GT | GE | LE | LT | NE) operand2=ComparisonOperand)*
		public Group getGroup_1() { return cGroup_1; }

		//{LogicalOperand.operand1=current}
		public Action getLogicalOperandOperand1Action_1_0() { return cLogicalOperandOperand1Action_1_0; }

		//op=(EQ | GT | GE | LE | LT | NE)
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//EQ | GT | GE | LE | LT | NE
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//EQ
		public RuleCall getOpEQTerminalRuleCall_1_1_0_0() { return cOpEQTerminalRuleCall_1_1_0_0; }

		//GT
		public RuleCall getOpGTTerminalRuleCall_1_1_0_1() { return cOpGTTerminalRuleCall_1_1_0_1; }

		//GE
		public RuleCall getOpGETerminalRuleCall_1_1_0_2() { return cOpGETerminalRuleCall_1_1_0_2; }

		//LE
		public RuleCall getOpLETerminalRuleCall_1_1_0_3() { return cOpLETerminalRuleCall_1_1_0_3; }

		//LT
		public RuleCall getOpLTTerminalRuleCall_1_1_0_4() { return cOpLTTerminalRuleCall_1_1_0_4; }

		//NE
		public RuleCall getOpNETerminalRuleCall_1_1_0_5() { return cOpNETerminalRuleCall_1_1_0_5; }

		//operand2=ComparisonOperand
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//ComparisonOperand
		public RuleCall getOperand2ComparisonOperandParserRuleCall_1_2_0() { return cOperand2ComparisonOperandParserRuleCall_1_2_0; }
	}

	public class ComparisonOperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonOperand");
		private final RuleCall cAccessExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// access base expressions can have array or member accesses composed on the right
		//ComparisonOperand returns Expression:
		//	AccessExpr;
		public ParserRule getRule() { return rule; }

		//AccessExpr
		public RuleCall getAccessExprParserRuleCall() { return cAccessExprParserRuleCall; }
	}

	public class AccessExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AccessExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAccessBaseExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cAccessExprOperand1Action_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpLSQUARETerminalRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cOperand2ExpressionParserRuleCall_1_0_2_0 = (RuleCall)cOperand2Assignment_1_0_2.eContents().get(0);
		private final RuleCall cRSQUARETerminalRuleCall_1_0_3 = (RuleCall)cGroup_1_0.eContents().get(3);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cAccessExprOperand1Action_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cOpDOTTerminalRuleCall_1_1_1_0 = (RuleCall)cOpAssignment_1_1_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cValueIDTerminalRuleCall_1_1_2_0 = (RuleCall)cValueAssignment_1_1_2.eContents().get(0);
		private final Assignment cArgsAssignment_1_1_3 = (Assignment)cGroup_1_1.eContents().get(3);
		private final RuleCall cArgsCallArgumentsParserRuleCall_1_1_3_0 = (RuleCall)cArgsAssignment_1_1_3.eContents().get(0);
		
		//// we need to return the LHS type so we can recurse here
		//AccessExpr returns Expression:
		//	AccessBaseExpr ({AccessExpr.operand1=current} op=LSQUARE operand2=Expression RSQUARE | {AccessExpr.operand1=current}
		//	op=DOT value=ID args=CallArguments?)*;
		public ParserRule getRule() { return rule; }

		//AccessBaseExpr ({AccessExpr.operand1=current} op=LSQUARE operand2=Expression RSQUARE | {AccessExpr.operand1=current}
		//op=DOT value=ID args=CallArguments?)*
		public Group getGroup() { return cGroup; }

		//AccessBaseExpr
		public RuleCall getAccessBaseExprParserRuleCall_0() { return cAccessBaseExprParserRuleCall_0; }

		//({AccessExpr.operand1=current} op=LSQUARE operand2=Expression RSQUARE | {AccessExpr.operand1=current} op=DOT value=ID
		//args=CallArguments?)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{AccessExpr.operand1=current} op=LSQUARE operand2=Expression RSQUARE
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{AccessExpr.operand1=current}
		public Action getAccessExprOperand1Action_1_0_0() { return cAccessExprOperand1Action_1_0_0; }

		//op=LSQUARE
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }

		//LSQUARE
		public RuleCall getOpLSQUARETerminalRuleCall_1_0_1_0() { return cOpLSQUARETerminalRuleCall_1_0_1_0; }

		//operand2=Expression
		public Assignment getOperand2Assignment_1_0_2() { return cOperand2Assignment_1_0_2; }

		//Expression
		public RuleCall getOperand2ExpressionParserRuleCall_1_0_2_0() { return cOperand2ExpressionParserRuleCall_1_0_2_0; }

		//RSQUARE
		public RuleCall getRSQUARETerminalRuleCall_1_0_3() { return cRSQUARETerminalRuleCall_1_0_3; }

		//{AccessExpr.operand1=current} op=DOT value=ID args=CallArguments?
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{AccessExpr.operand1=current}
		public Action getAccessExprOperand1Action_1_1_0() { return cAccessExprOperand1Action_1_1_0; }

		//op=DOT
		public Assignment getOpAssignment_1_1_1() { return cOpAssignment_1_1_1; }

		//DOT
		public RuleCall getOpDOTTerminalRuleCall_1_1_1_0() { return cOpDOTTerminalRuleCall_1_1_1_0; }

		//value=ID
		public Assignment getValueAssignment_1_1_2() { return cValueAssignment_1_1_2; }

		//ID
		public RuleCall getValueIDTerminalRuleCall_1_1_2_0() { return cValueIDTerminalRuleCall_1_1_2_0; }

		//args=CallArguments?
		public Assignment getArgsAssignment_1_1_3() { return cArgsAssignment_1_1_3; }

		//CallArguments
		public RuleCall getArgsCallArgumentsParserRuleCall_1_1_3_0() { return cArgsCallArgumentsParserRuleCall_1_1_3_0; }
	}

	public class AccessBaseExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AccessBaseExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBuiltinExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSimpleExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// *
		//AccessExpr returns Expression :
		//	AccessBaseExpr ({AccessExpr.operand1 = current} access = Access)*
		//	;
		//	
		//Access :
		//	IndexAccess |
		//	MemberAccess
		//;
		//
		//IndexAccess:
		//{IndexAccess}
		//	LSQUARE (index=Expression) RSQUARE;
		//
		//MemberAccess :
		//  (op=DOT memberName=ID (args=CallArguments)?) ;
		// * / // access base expressions are either simple builtin calls or var references,
		//// literals, new expressions and bracketed expressions. they may possibly be
		//// accessed on the left before being composed with prefix or infix operators
		//AccessBaseExpr returns Expression:
		//	BuiltinExpr | SimpleExpr;
		public ParserRule getRule() { return rule; }

		//BuiltinExpr | SimpleExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//BuiltinExpr
		public RuleCall getBuiltinExprParserRuleCall_0() { return cBuiltinExprParserRuleCall_0; }

		//SimpleExpr
		public RuleCall getSimpleExprParserRuleCall_1() { return cSimpleExprParserRuleCall_1; }
	}

	public class BuiltinExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuiltinExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuiltinExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueIDTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Assignment cArgsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgsCallArgumentsParserRuleCall_2_0 = (RuleCall)cArgsAssignment_2.eContents().get(0);
		
		//BuiltinExpr returns Expression:
		//	{BuiltinExpr} value=ID args=CallArguments;
		public ParserRule getRule() { return rule; }

		//{BuiltinExpr} value=ID args=CallArguments
		public Group getGroup() { return cGroup; }

		//{BuiltinExpr}
		public Action getBuiltinExprAction_0() { return cBuiltinExprAction_0; }

		//value=ID
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//ID
		public RuleCall getValueIDTerminalRuleCall_1_0() { return cValueIDTerminalRuleCall_1_0; }

		//args=CallArguments
		public Assignment getArgsAssignment_2() { return cArgsAssignment_2; }

		//CallArguments
		public RuleCall getArgsCallArgumentsParserRuleCall_2_0() { return cArgsCallArgumentsParserRuleCall_2_0; }
	}

	public class SimpleExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstantExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBracketedExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cNewExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		/// *
		// * TODO still need to allow for ternary (c ? e1 : e2) expressions
		// * / SimpleExpr returns Expression:
		//	VariableExpr | ConstantExpr | BracketedExpr | NewExpr;
		public ParserRule getRule() { return rule; }

		//VariableExpr | ConstantExpr | BracketedExpr | NewExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//VariableExpr
		public RuleCall getVariableExprParserRuleCall_0() { return cVariableExprParserRuleCall_0; }

		//ConstantExpr
		public RuleCall getConstantExprParserRuleCall_1() { return cConstantExprParserRuleCall_1; }

		//BracketedExpr
		public RuleCall getBracketedExprParserRuleCall_2() { return cBracketedExprParserRuleCall_2; }

		//NewExpr
		public RuleCall getNewExprParserRuleCall_3() { return cNewExprParserRuleCall_3; }
	}

	public class NewExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NewExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNewExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpNEWTerminalRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueQualifiedNameParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Assignment cParamsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamsCallArgumentsParserRuleCall_3_0 = (RuleCall)cParamsAssignment_3.eContents().get(0);
		
		//NewExpr returns Expression:
		//	{NewExpr} op=NEW value=QualifiedName params=CallArguments;
		public ParserRule getRule() { return rule; }

		//{NewExpr} op=NEW value=QualifiedName params=CallArguments
		public Group getGroup() { return cGroup; }

		//{NewExpr}
		public Action getNewExprAction_0() { return cNewExprAction_0; }

		//op=NEW
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//NEW
		public RuleCall getOpNEWTerminalRuleCall_1_0() { return cOpNEWTerminalRuleCall_1_0; }

		//value=QualifiedName
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//QualifiedName
		public RuleCall getValueQualifiedNameParserRuleCall_2_0() { return cValueQualifiedNameParserRuleCall_2_0; }

		//params=CallArguments
		public Assignment getParamsAssignment_3() { return cParamsAssignment_3; }

		//CallArguments
		public RuleCall getParamsCallArgumentsParserRuleCall_3_0() { return cParamsCallArgumentsParserRuleCall_3_0; }
	}

	public class VariableExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSimpleNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIndexedSpecialVarParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSpecialVarParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//VariableExpr returns Expression:
		//	SimpleName | IndexedSpecialVar | SpecialVar;
		public ParserRule getRule() { return rule; }

		//SimpleName | IndexedSpecialVar | SpecialVar
		public Alternatives getAlternatives() { return cAlternatives; }

		//SimpleName
		public RuleCall getSimpleNameParserRuleCall_0() { return cSimpleNameParserRuleCall_0; }

		//IndexedSpecialVar
		public RuleCall getIndexedSpecialVarParserRuleCall_1() { return cIndexedSpecialVarParserRuleCall_1; }

		//SpecialVar
		public RuleCall getSpecialVarParserRuleCall_2() { return cSpecialVarParserRuleCall_2; }
	}

	public class CallArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CallArguments");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLPARENTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Action cCallArgumentsAction_1 = (Action)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cArgsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cArgsExpressionParserRuleCall_2_0_0 = (RuleCall)cArgsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final RuleCall cCOMMATerminalRuleCall_2_1_0 = (RuleCall)cGroup_2_1.eContents().get(0);
		private final Assignment cArgsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cArgsExpressionParserRuleCall_2_1_1_0 = (RuleCall)cArgsAssignment_2_1_1.eContents().get(0);
		private final RuleCall cRPARENTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//CallArguments:
		//	LPAREN {CallArguments} (args+=Expression (COMMA args+=Expression)*)? RPAREN;
		public ParserRule getRule() { return rule; }

		//LPAREN {CallArguments} (args+=Expression (COMMA args+=Expression)*)? RPAREN
		public Group getGroup() { return cGroup; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_0() { return cLPARENTerminalRuleCall_0; }

		//{CallArguments}
		public Action getCallArgumentsAction_1() { return cCallArgumentsAction_1; }

		//(args+=Expression (COMMA args+=Expression)*)?
		public Group getGroup_2() { return cGroup_2; }

		//args+=Expression
		public Assignment getArgsAssignment_2_0() { return cArgsAssignment_2_0; }

		//Expression
		public RuleCall getArgsExpressionParserRuleCall_2_0_0() { return cArgsExpressionParserRuleCall_2_0_0; }

		//(COMMA args+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_2_1_0() { return cCOMMATerminalRuleCall_2_1_0; }

		//args+=Expression
		public Assignment getArgsAssignment_2_1_1() { return cArgsAssignment_2_1_1; }

		//Expression
		public RuleCall getArgsExpressionParserRuleCall_2_1_1_0() { return cArgsExpressionParserRuleCall_2_1_1_0; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_3() { return cRPARENTerminalRuleCall_3; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cDOTTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	ID (DOT ID)*;
		public ParserRule getRule() { return rule; }

		//ID (DOT ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//(DOT ID)*
		public Group getGroup_1() { return cGroup_1; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_1_0() { return cDOTTerminalRuleCall_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}

	public class SimpleNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSimpleNameAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueIDTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//SimpleName returns Expression:
		//	{SimpleName} value=ID;
		public ParserRule getRule() { return rule; }

		//{SimpleName} value=ID
		public Group getGroup() { return cGroup; }

		//{SimpleName}
		public Action getSimpleNameAction_0() { return cSimpleNameAction_0; }

		//value=ID
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//ID
		public RuleCall getValueIDTerminalRuleCall_1_0() { return cValueIDTerminalRuleCall_1_0; }
	}

	public class IndexedSpecialVarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IndexedSpecialVar");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIndexedSpecialVarAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpDOLLARTerminalRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueINTVALTerminalRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//IndexedSpecialVar returns Expression:
		//	{IndexedSpecialVar} op=DOLLAR value=INTVAL;
		public ParserRule getRule() { return rule; }

		//{IndexedSpecialVar} op=DOLLAR value=INTVAL
		public Group getGroup() { return cGroup; }

		//{IndexedSpecialVar}
		public Action getIndexedSpecialVarAction_0() { return cIndexedSpecialVarAction_0; }

		//op=DOLLAR
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//DOLLAR
		public RuleCall getOpDOLLARTerminalRuleCall_1_0() { return cOpDOLLARTerminalRuleCall_1_0; }

		//value=INTVAL
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//INTVAL
		public RuleCall getValueINTVALTerminalRuleCall_2_0() { return cValueINTVALTerminalRuleCall_2_0; }
	}

	public class SpecialVarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SpecialVar");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSpecialVarAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cOpAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final Keyword cOpDollarSignNumberSignKeyword_1_0_0 = (Keyword)cOpAssignment_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final Keyword cOpDollarSignExclamationMarkKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cOpAssignment_1_2 = (Assignment)cAlternatives_1.eContents().get(2);
		private final Keyword cOpDollarSignCircumflexAccentKeyword_1_2_0 = (Keyword)cOpAssignment_1_2.eContents().get(0);
		private final Assignment cOpAssignment_1_3 = (Assignment)cAlternatives_1.eContents().get(3);
		private final Keyword cOpDollarSignCommercialAtKeyword_1_3_0 = (Keyword)cOpAssignment_1_3.eContents().get(0);
		private final Assignment cOpAssignment_1_4 = (Assignment)cAlternatives_1.eContents().get(4);
		private final Keyword cOpDollarSignAsteriskKeyword_1_4_0 = (Keyword)cOpAssignment_1_4.eContents().get(0);
		private final Group cGroup_1_5 = (Group)cAlternatives_1.eContents().get(5);
		private final Assignment cOpAssignment_1_5_0 = (Assignment)cGroup_1_5.eContents().get(0);
		private final RuleCall cOpDOLLARTerminalRuleCall_1_5_0_0 = (RuleCall)cOpAssignment_1_5_0.eContents().get(0);
		private final Assignment cValueAssignment_1_5_1 = (Assignment)cGroup_1_5.eContents().get(1);
		private final RuleCall cValueIDTerminalRuleCall_1_5_1_0 = (RuleCall)cValueAssignment_1_5_1.eContents().get(0);
		
		//SpecialVar returns Expression:
		//	{SpecialVar} (op="$#" | op="$!" | op="$^" | op="$@" | op="$*" | op=DOLLAR value=ID);
		public ParserRule getRule() { return rule; }

		//{SpecialVar} (op="$#" | op="$!" | op="$^" | op="$@" | op="$*" | op=DOLLAR value=ID)
		public Group getGroup() { return cGroup; }

		//{SpecialVar}
		public Action getSpecialVarAction_0() { return cSpecialVarAction_0; }

		//op="$#" | op="$!" | op="$^" | op="$@" | op="$*" | op=DOLLAR value=ID
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//op="$#"
		public Assignment getOpAssignment_1_0() { return cOpAssignment_1_0; }

		//"$#"
		public Keyword getOpDollarSignNumberSignKeyword_1_0_0() { return cOpDollarSignNumberSignKeyword_1_0_0; }

		//op="$!"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//"$!"
		public Keyword getOpDollarSignExclamationMarkKeyword_1_1_0() { return cOpDollarSignExclamationMarkKeyword_1_1_0; }

		//op="$^"
		public Assignment getOpAssignment_1_2() { return cOpAssignment_1_2; }

		//"$^"
		public Keyword getOpDollarSignCircumflexAccentKeyword_1_2_0() { return cOpDollarSignCircumflexAccentKeyword_1_2_0; }

		//op="$@"
		public Assignment getOpAssignment_1_3() { return cOpAssignment_1_3; }

		//"$@"
		public Keyword getOpDollarSignCommercialAtKeyword_1_3_0() { return cOpDollarSignCommercialAtKeyword_1_3_0; }

		//op="$*"
		public Assignment getOpAssignment_1_4() { return cOpAssignment_1_4; }

		//"$*"
		public Keyword getOpDollarSignAsteriskKeyword_1_4_0() { return cOpDollarSignAsteriskKeyword_1_4_0; }

		//op=DOLLAR value=ID
		public Group getGroup_1_5() { return cGroup_1_5; }

		//op=DOLLAR
		public Assignment getOpAssignment_1_5_0() { return cOpAssignment_1_5_0; }

		//DOLLAR
		public RuleCall getOpDOLLARTerminalRuleCall_1_5_0_0() { return cOpDOLLARTerminalRuleCall_1_5_0_0; }

		//value=ID
		public Assignment getValueAssignment_1_5_1() { return cValueAssignment_1_5_1; }

		//ID
		public RuleCall getValueIDTerminalRuleCall_1_5_1_0() { return cValueIDTerminalRuleCall_1_5_1_0; }
	}

	public class BracketedExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BracketedExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLPARENTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cRPARENTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//BracketedExpr returns Expression:
		//	LPAREN Expression RPAREN;
		public ParserRule getRule() { return rule; }

		//LPAREN Expression RPAREN
		public Group getGroup() { return cGroup; }

		//LPAREN
		public RuleCall getLPARENTerminalRuleCall_0() { return cLPARENTerminalRuleCall_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//RPAREN
		public RuleCall getRPARENTerminalRuleCall_2() { return cRPARENTerminalRuleCall_2; }
	}

	public class ConstantExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntConstantExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringConstantExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanConstantExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFloatConstantExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ConstantExpr returns Expression:
		//	IntConstantExpr | StringConstantExpr | BooleanConstantExpr | FloatConstantExpr;
		public ParserRule getRule() { return rule; }

		//IntConstantExpr | StringConstantExpr | BooleanConstantExpr | FloatConstantExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//IntConstantExpr
		public RuleCall getIntConstantExprParserRuleCall_0() { return cIntConstantExprParserRuleCall_0; }

		//StringConstantExpr
		public RuleCall getStringConstantExprParserRuleCall_1() { return cStringConstantExprParserRuleCall_1; }

		//BooleanConstantExpr
		public RuleCall getBooleanConstantExprParserRuleCall_2() { return cBooleanConstantExprParserRuleCall_2; }

		//FloatConstantExpr
		public RuleCall getFloatConstantExprParserRuleCall_3() { return cFloatConstantExprParserRuleCall_3; }
	}

	public class IntConstantExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntConstantExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntConstantExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueINTVALTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//IntConstantExpr returns Expression:
		//	{IntConstantExpr} value=INTVAL;
		public ParserRule getRule() { return rule; }

		//{IntConstantExpr} value=INTVAL
		public Group getGroup() { return cGroup; }

		//{IntConstantExpr}
		public Action getIntConstantExprAction_0() { return cIntConstantExprAction_0; }

		//value=INTVAL
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//INTVAL
		public RuleCall getValueINTVALTerminalRuleCall_1_0() { return cValueINTVALTerminalRuleCall_1_0; }
	}

	public class StringConstantExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringConstantExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStringConstantExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//StringConstantExpr returns Expression:
		//	{StringConstantExpr} value=STRING;
		public ParserRule getRule() { return rule; }

		//{StringConstantExpr} value=STRING
		public Group getGroup() { return cGroup; }

		//{StringConstantExpr}
		public Action getStringConstantExprAction_0() { return cStringConstantExprAction_0; }

		//value=STRING
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0() { return cValueSTRINGTerminalRuleCall_1_0; }
	}

	public class BooleanConstantExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanConstantExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBooleanConstantExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueBOOLEANTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//BooleanConstantExpr returns Expression:
		//	{BooleanConstantExpr} value=BOOLEAN;
		public ParserRule getRule() { return rule; }

		//{BooleanConstantExpr} value=BOOLEAN
		public Group getGroup() { return cGroup; }

		//{BooleanConstantExpr}
		public Action getBooleanConstantExprAction_0() { return cBooleanConstantExprAction_0; }

		//value=BOOLEAN
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//BOOLEAN
		public RuleCall getValueBOOLEANTerminalRuleCall_1_0() { return cValueBOOLEANTerminalRuleCall_1_0; }
	}

	public class FloatConstantExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FloatConstantExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFloatConstantExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueFLOATVALTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//FloatConstantExpr returns Expression:
		//	{FloatConstantExpr} value=FLOATVAL;
		public ParserRule getRule() { return rule; }

		//{FloatConstantExpr} value=FLOATVAL
		public Group getGroup() { return cGroup; }

		//{FloatConstantExpr}
		public Action getFloatConstantExprAction_0() { return cFloatConstantExprAction_0; }

		//value=FLOATVAL
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//FLOATVAL
		public RuleCall getValueFLOATVALTerminalRuleCall_1_0() { return cValueFLOATVALTerminalRuleCall_1_0; }
	}
	
	
	private DomainModelElements pDomainModel;
	private ElementElements pElement;
	private BytemanRuleElements pBytemanRule;
	private BodyElements pBody;
	private EventElements pEvent;
	private EventClassElements pEventClass;
	private EventInterfaceElements pEventInterface;
	private EventMethodElements pEventMethod;
	private MethodNameElements pMethodName;
	private HelperElements pHelper;
	private LocationSpecifierElements pLocationSpecifier;
	private AtLocationElements pAtLocation;
	private AfterLocationElements pAfterLocation;
	private AtEntryElements pAtEntry;
	private AtExitElements pAtExit;
	private AtLineElements pAtLine;
	private AtReadElements pAtRead;
	private AtReadFieldElements pAtReadField;
	private AtReadLocalElements pAtReadLocal;
	private AfterReadElements pAfterRead;
	private AfterReadFieldElements pAfterReadField;
	private AfterReadLocalElements pAfterReadLocal;
	private AtWriteElements pAtWrite;
	private AtWriteFieldElements pAtWriteField;
	private AtWriteLocalElements pAtWriteLocal;
	private AfterWriteElements pAfterWrite;
	private AfterWriteFieldElements pAfterWriteField;
	private AfterWriteLocalElements pAfterWriteLocal;
	private AtInvokeElements pAtInvoke;
	private AfterInvokeElements pAfterInvoke;
	private AtSynchronizeElements pAtSynchronize;
	private AfterSynchronizeElements pAfterSynchronize;
	private AtThrowElements pAtThrow;
	private ParameterTypesElements pParameterTypes;
	private ParamTypeNameElements pParamTypeName;
	private CounterElements pCounter;
	private BindElements pBind;
	private BindingsElements pBindings;
	private BindingElements pBinding;
	private BindVariableElements pBindVariable;
	private TypeNameElements pTypeName;
	private ConditionElements pCondition;
	private ActionsElements pActions;
	private ActionListElements pActionList;
	private ActionElements pAction;
	private ExpressionElements pExpression;
	private ReturnExprElements pReturnExpr;
	private ThrowExprElements pThrowExpr;
	private AssignmentExprElements pAssignmentExpr;
	private OperatorExprElements pOperatorExpr;
	private PlusMinusOperandElements pPlusMinusOperand;
	private TimesDivOperandElements pTimesDivOperand;
	private BitwiseOperandElements pBitwiseOperand;
	private NotOperandElements pNotOperand;
	private LogicalOperandElements pLogicalOperand;
	private ComparisonOperandElements pComparisonOperand;
	private AccessExprElements pAccessExpr;
	private AccessBaseExprElements pAccessBaseExpr;
	private BuiltinExprElements pBuiltinExpr;
	private SimpleExprElements pSimpleExpr;
	private NewExprElements pNewExpr;
	private VariableExprElements pVariableExpr;
	private CallArgumentsElements pCallArguments;
	private QualifiedNameElements pQualifiedName;
	private SimpleNameElements pSimpleName;
	private IndexedSpecialVarElements pIndexedSpecialVar;
	private SpecialVarElements pSpecialVar;
	private BracketedExprElements pBracketedExpr;
	private ConstantExprElements pConstantExpr;
	private IntConstantExprElements pIntConstantExpr;
	private StringConstantExprElements pStringConstantExpr;
	private BooleanConstantExprElements pBooleanConstantExpr;
	private FloatConstantExprElements pFloatConstantExpr;
	private TerminalRule tQMARK;
	private TerminalRule tCOMMA;
	private TerminalRule tDOT;
	private TerminalRule tCOLON;
	private TerminalRule tNULL;
	private TerminalRule tNEW;
	private TerminalRule tSEMICOLON;
	private TerminalRule tBOOLEAN;
	private TerminalRule tINIT;
	private TerminalRule tCLINIT;
	private TerminalRule tLPAREN;
	private TerminalRule tRPAREN;
	private TerminalRule tLSQUARE;
	private TerminalRule tRSQUARE;
	private TerminalRule tDOLLAR;
	private TerminalRule tPLUS;
	private TerminalRule tMINUS;
	private TerminalRule tMOD;
	private TerminalRule tDIV;
	private TerminalRule tTIMES;
	private TerminalRule tBAND;
	private TerminalRule tBOR;
	private TerminalRule tBNOT;
	private TerminalRule tBXOR;
	private TerminalRule tLT;
	private TerminalRule tLE;
	private TerminalRule tGT;
	private TerminalRule tGE;
	private TerminalRule tEQ;
	private TerminalRule tNE;
	private TerminalRule tASSIGN;
	private TerminalRule tFLOATVAL;
	private TerminalRule tINTVAL;
	private TerminalRule tEXPONENT;
	private TerminalRule tFLOATTYPESUFFIX;
	private TerminalRule tINTTYPESUFFIX;
	private TerminalRule tOR;
	private TerminalRule tAND;
	private TerminalRule tNOT;
	private TerminalRule tKEYWORD_CLASS;
	private TerminalRule tKEYWORD_METHOD;
	private TerminalRule tKEYWORD_INTERFACE;
	private TerminalRule tIF;
	private TerminalRule tKEYWORD_BIND;
	private TerminalRule tNOTHING;
	private TerminalRule tKEYWORD_THROW;
	private TerminalRule tKEYWORD_RETURN;
	private TerminalRule tDO;
	private TerminalRule tSTART_RULE;
	private TerminalRule tEND_RULE;
	private TerminalRule tID;
	private TerminalRule tSTRING;
	private TerminalRule tBM_COMMENT;
	private TerminalRule tHASH;
	private TerminalRule tEOL;
	private TerminalRule tWS;
	
	private final GrammarProvider grammarProvider;

	@Inject
	public BytemanGrammarAccess(GrammarProvider grammarProvider) {
		this.grammarProvider = grammarProvider;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	
	/// *
	//	Specification of the domain model allowing multiple rules in one script
	//	Specification of individual rules using event, condition and action
	//	
	//	n.b. WS and comments are hidden in the top level rules but there is
	//	explicit end of line (EOL) handling because the RULE, CLASS/INTERFACE,
	//	METHOD, AT and ENDRULE keyword elements of the rule are line oriented
	// * / DomainModel:
	//	{DomainModel} (elements+=Element | EOL)*;
	public DomainModelElements getDomainModelAccess() {
		return (pDomainModel != null) ? pDomainModel : (pDomainModel = new DomainModelElements());
	}
	
	public ParserRule getDomainModelRule() {
		return getDomainModelAccess().getRule();
	}

	//Element:
	//	BytemanRule | Helper;
	public ElementElements getElementAccess() {
		return (pElement != null) ? pElement : (pElement = new ElementElements());
	}
	
	public ParserRule getElementRule() {
		return getElementAccess().getRule();
	}

	//BytemanRule:
	//	name=START_RULE EOL* event=Event body=Body END_RULE EOL;
	public BytemanRuleElements getBytemanRuleAccess() {
		return (pBytemanRule != null) ? pBytemanRule : (pBytemanRule = new BytemanRuleElements());
	}
	
	public ParserRule getBytemanRuleRule() {
		return getBytemanRuleAccess().getRule();
	}

	/// *
	// * the rule body is not line-oriented so we ignore EOL below this part
	// * / Body hidden(WS, BM_COMMENT, EOL):
	//	bind=Bind? condition=Condition actions=Actions;
	public BodyElements getBodyAccess() {
		return (pBody != null) ? pBody : (pBody = new BodyElements());
	}
	
	public ParserRule getBodyRule() {
		return getBodyAccess().getRule();
	}

	/// *
	//	Definition of the event
	// * / Event:
	//	(class=EventClass | interface=EventInterface) EOL* method=EventMethod EOL* (helper=Helper EOL*)?
	//	(locationSpec=LocationSpecifier EOL*)?;
	public EventElements getEventAccess() {
		return (pEvent != null) ? pEvent : (pEvent = new EventElements());
	}
	
	public ParserRule getEventRule() {
		return getEventAccess().getRule();
	}

	//EventClass:
	//	keyword=KEYWORD_CLASS name=QualifiedName;
	public EventClassElements getEventClassAccess() {
		return (pEventClass != null) ? pEventClass : (pEventClass = new EventClassElements());
	}
	
	public ParserRule getEventClassRule() {
		return getEventClassAccess().getRule();
	}

	//EventInterface:
	//	keyword=KEYWORD_INTERFACE name=QualifiedName;
	public EventInterfaceElements getEventInterfaceAccess() {
		return (pEventInterface != null) ? pEventInterface : (pEventInterface = new EventInterfaceElements());
	}
	
	public ParserRule getEventInterfaceRule() {
		return getEventInterfaceAccess().getRule();
	}

	//EventMethod:
	//	KEYWORD_METHOD name=MethodName parameterTypes=ParameterTypes?;
	public EventMethodElements getEventMethodAccess() {
		return (pEventMethod != null) ? pEventMethod : (pEventMethod = new EventMethodElements());
	}
	
	public ParserRule getEventMethodRule() {
		return getEventMethodAccess().getRule();
	}

	//MethodName:
	//	ID | INIT | CLINIT;
	public MethodNameElements getMethodNameAccess() {
		return (pMethodName != null) ? pMethodName : (pMethodName = new MethodNameElements());
	}
	
	public ParserRule getMethodNameRule() {
		return getMethodNameAccess().getRule();
	}

	//Helper:
	//	{Helper} "HELPER" helper=QualifiedName?;
	public HelperElements getHelperAccess() {
		return (pHelper != null) ? pHelper : (pHelper = new HelperElements());
	}
	
	public ParserRule getHelperRule() {
		return getHelperAccess().getRule();
	}

	//LocationSpecifier:
	//	"AT" AtLocation | "AFTER" AfterLocation | AtLine;
	public LocationSpecifierElements getLocationSpecifierAccess() {
		return (pLocationSpecifier != null) ? pLocationSpecifier : (pLocationSpecifier = new LocationSpecifierElements());
	}
	
	public ParserRule getLocationSpecifierRule() {
		return getLocationSpecifierAccess().getRule();
	}

	//AtLocation:
	//	AtEntry | AtExit | AtLine | AtRead | AtWrite | AtInvoke | AtSynchronize | AtThrow;
	public AtLocationElements getAtLocationAccess() {
		return (pAtLocation != null) ? pAtLocation : (pAtLocation = new AtLocationElements());
	}
	
	public ParserRule getAtLocationRule() {
		return getAtLocationAccess().getRule();
	}

	//AfterLocation:
	//	AfterRead | AfterWrite | AfterInvoke | AfterSynchronize | AtThrow;
	public AfterLocationElements getAfterLocationAccess() {
		return (pAfterLocation != null) ? pAfterLocation : (pAfterLocation = new AfterLocationElements());
	}
	
	public ParserRule getAfterLocationRule() {
		return getAfterLocationAccess().getRule();
	}

	//AtEntry:
	//	{AtEntry} "ENTRY";
	public AtEntryElements getAtEntryAccess() {
		return (pAtEntry != null) ? pAtEntry : (pAtEntry = new AtEntryElements());
	}
	
	public ParserRule getAtEntryRule() {
		return getAtEntryAccess().getRule();
	}

	//AtExit:
	//	{AtExit} ("EXIT" | KEYWORD_RETURN);
	public AtExitElements getAtExitAccess() {
		return (pAtExit != null) ? pAtExit : (pAtExit = new AtExitElements());
	}
	
	public ParserRule getAtExitRule() {
		return getAtExitAccess().getRule();
	}

	//AtLine:
	//	{AtLine} "LINE" line=INTVAL;
	public AtLineElements getAtLineAccess() {
		return (pAtLine != null) ? pAtLine : (pAtLine = new AtLineElements());
	}
	
	public ParserRule getAtLineRule() {
		return getAtLineAccess().getRule();
	}

	//AtRead:
	//	AtReadField | AtReadLocal;
	public AtReadElements getAtReadAccess() {
		return (pAtRead != null) ? pAtRead : (pAtRead = new AtReadElements());
	}
	
	public ParserRule getAtReadRule() {
		return getAtReadAccess().getRule();
	}

	//AtReadField:
	//	{AtReadField} "READ" name=QualifiedName counter=Counter?;
	public AtReadFieldElements getAtReadFieldAccess() {
		return (pAtReadField != null) ? pAtReadField : (pAtReadField = new AtReadFieldElements());
	}
	
	public ParserRule getAtReadFieldRule() {
		return getAtReadFieldAccess().getRule();
	}

	//AtReadLocal:
	//	{AtReadLocal} "READ" DOLLAR name=ID counter=Counter?;
	public AtReadLocalElements getAtReadLocalAccess() {
		return (pAtReadLocal != null) ? pAtReadLocal : (pAtReadLocal = new AtReadLocalElements());
	}
	
	public ParserRule getAtReadLocalRule() {
		return getAtReadLocalAccess().getRule();
	}

	//AfterRead:
	//	AfterReadField | AfterReadLocal;
	public AfterReadElements getAfterReadAccess() {
		return (pAfterRead != null) ? pAfterRead : (pAfterRead = new AfterReadElements());
	}
	
	public ParserRule getAfterReadRule() {
		return getAfterReadAccess().getRule();
	}

	//AfterReadField:
	//	{AfterReadField} "READ" name=QualifiedName counter=Counter?;
	public AfterReadFieldElements getAfterReadFieldAccess() {
		return (pAfterReadField != null) ? pAfterReadField : (pAfterReadField = new AfterReadFieldElements());
	}
	
	public ParserRule getAfterReadFieldRule() {
		return getAfterReadFieldAccess().getRule();
	}

	//AfterReadLocal:
	//	{AfterReadLocal} "READ" DOLLAR name=ID counter=Counter?;
	public AfterReadLocalElements getAfterReadLocalAccess() {
		return (pAfterReadLocal != null) ? pAfterReadLocal : (pAfterReadLocal = new AfterReadLocalElements());
	}
	
	public ParserRule getAfterReadLocalRule() {
		return getAfterReadLocalAccess().getRule();
	}

	//AtWrite:
	//	AtWriteField | AtWriteLocal;
	public AtWriteElements getAtWriteAccess() {
		return (pAtWrite != null) ? pAtWrite : (pAtWrite = new AtWriteElements());
	}
	
	public ParserRule getAtWriteRule() {
		return getAtWriteAccess().getRule();
	}

	//AtWriteField:
	//	{AtWriteField} "WRITE" name=QualifiedName counter=Counter?;
	public AtWriteFieldElements getAtWriteFieldAccess() {
		return (pAtWriteField != null) ? pAtWriteField : (pAtWriteField = new AtWriteFieldElements());
	}
	
	public ParserRule getAtWriteFieldRule() {
		return getAtWriteFieldAccess().getRule();
	}

	//AtWriteLocal:
	//	{AtWriteLocal} "WRITE" DOLLAR name=ID counter=Counter?;
	public AtWriteLocalElements getAtWriteLocalAccess() {
		return (pAtWriteLocal != null) ? pAtWriteLocal : (pAtWriteLocal = new AtWriteLocalElements());
	}
	
	public ParserRule getAtWriteLocalRule() {
		return getAtWriteLocalAccess().getRule();
	}

	//AfterWrite:
	//	AfterWriteField | AfterWriteLocal;
	public AfterWriteElements getAfterWriteAccess() {
		return (pAfterWrite != null) ? pAfterWrite : (pAfterWrite = new AfterWriteElements());
	}
	
	public ParserRule getAfterWriteRule() {
		return getAfterWriteAccess().getRule();
	}

	//AfterWriteField:
	//	{AfterWriteField} "WRITE" name=QualifiedName counter=Counter?;
	public AfterWriteFieldElements getAfterWriteFieldAccess() {
		return (pAfterWriteField != null) ? pAfterWriteField : (pAfterWriteField = new AfterWriteFieldElements());
	}
	
	public ParserRule getAfterWriteFieldRule() {
		return getAfterWriteFieldAccess().getRule();
	}

	//AfterWriteLocal:
	//	{AfterWriteLocal} "WRITE" DOLLAR name=ID counter=Counter?;
	public AfterWriteLocalElements getAfterWriteLocalAccess() {
		return (pAfterWriteLocal != null) ? pAfterWriteLocal : (pAfterWriteLocal = new AfterWriteLocalElements());
	}
	
	public ParserRule getAfterWriteLocalRule() {
		return getAfterWriteLocalAccess().getRule();
	}

	//AtInvoke:
	//	{AtInvoke} ("INVOKE" | "CALL") name=QualifiedName parameterTypes=ParameterTypes? counter=Counter?;
	public AtInvokeElements getAtInvokeAccess() {
		return (pAtInvoke != null) ? pAtInvoke : (pAtInvoke = new AtInvokeElements());
	}
	
	public ParserRule getAtInvokeRule() {
		return getAtInvokeAccess().getRule();
	}

	//AfterInvoke:
	//	{AfterInvoke} ("INVOKE" | "CALL") name=QualifiedName parameterTypes=ParameterTypes? counter=Counter?;
	public AfterInvokeElements getAfterInvokeAccess() {
		return (pAfterInvoke != null) ? pAfterInvoke : (pAfterInvoke = new AfterInvokeElements());
	}
	
	public ParserRule getAfterInvokeRule() {
		return getAfterInvokeAccess().getRule();
	}

	//AtSynchronize:
	//	{AtSynchronize} "SYNCHRONIZE" counter=Counter?;
	public AtSynchronizeElements getAtSynchronizeAccess() {
		return (pAtSynchronize != null) ? pAtSynchronize : (pAtSynchronize = new AtSynchronizeElements());
	}
	
	public ParserRule getAtSynchronizeRule() {
		return getAtSynchronizeAccess().getRule();
	}

	//AfterSynchronize:
	//	{AfterSynchronize} "SYNCHRONIZE" counter=Counter?;
	public AfterSynchronizeElements getAfterSynchronizeAccess() {
		return (pAfterSynchronize != null) ? pAfterSynchronize : (pAfterSynchronize = new AfterSynchronizeElements());
	}
	
	public ParserRule getAfterSynchronizeRule() {
		return getAfterSynchronizeAccess().getRule();
	}

	//AtThrow:
	//	{AtThrow} "THROW" name=QualifiedName? counter=Counter?;
	public AtThrowElements getAtThrowAccess() {
		return (pAtThrow != null) ? pAtThrow : (pAtThrow = new AtThrowElements());
	}
	
	public ParserRule getAtThrowRule() {
		return getAtThrowAccess().getRule();
	}

	//ParameterTypes:
	//	LPAREN {ParameterTypes} (paramTypeNames+=ParamTypeName (COMMA paramTypeNames+=ParamTypeName)*)? RPAREN;
	public ParameterTypesElements getParameterTypesAccess() {
		return (pParameterTypes != null) ? pParameterTypes : (pParameterTypes = new ParameterTypesElements());
	}
	
	public ParserRule getParameterTypesRule() {
		return getParameterTypesAccess().getRule();
	}

	//ParamTypeName:
	//	QualifiedName;
	public ParamTypeNameElements getParamTypeNameAccess() {
		return (pParamTypeName != null) ? pParamTypeName : (pParamTypeName = new ParamTypeNameElements());
	}
	
	public ParserRule getParamTypeNameRule() {
		return getParamTypeNameAccess().getRule();
	}

	//Counter:
	//	INTVAL | "ALL";
	public CounterElements getCounterAccess() {
		return (pCounter != null) ? pCounter : (pCounter = new CounterElements());
	}
	
	public ParserRule getCounterRule() {
		return getCounterAccess().getRule();
	}

	//Bind:
	//	KEYWORD_BIND {Bind} (NOTHING | bind=Bindings);
	public BindElements getBindAccess() {
		return (pBind != null) ? pBind : (pBind = new BindElements());
	}
	
	public ParserRule getBindRule() {
		return getBindAccess().getRule();
	}

	//Bindings:
	//	bindings+=Binding (SEMICOLON bindings+=Binding)* SEMICOLON?;
	public BindingsElements getBindingsAccess() {
		return (pBindings != null) ? pBindings : (pBindings = new BindingsElements());
	}
	
	public ParserRule getBindingsRule() {
		return getBindingsAccess().getRule();
	}

	//Binding:
	//	bindVariable= // assignment is optional but only if we have a type
	//	BindVariable (ASSIGN value=Expression | (COLON typename=TypeName) (ASSIGN value=Expression)?);
	public BindingElements getBindingAccess() {
		return (pBinding != null) ? pBinding : (pBinding = new BindingElements());
	}
	
	public ParserRule getBindingRule() {
		return getBindingAccess().getRule();
	}

	//BindVariable:
	//	ID;
	public BindVariableElements getBindVariableAccess() {
		return (pBindVariable != null) ? pBindVariable : (pBindVariable = new BindVariableElements());
	}
	
	public ParserRule getBindVariableRule() {
		return getBindVariableAccess().getRule();
	}

	//TypeName:
	//	QualifiedName;
	public TypeNameElements getTypeNameAccess() {
		return (pTypeName != null) ? pTypeName : (pTypeName = new TypeNameElements());
	}
	
	public ParserRule getTypeNameRule() {
		return getTypeNameAccess().getRule();
	}

	/// *
	// * Definition of the Condition
	// * / Condition:
	//	IF Expression;
	public ConditionElements getConditionAccess() {
		return (pCondition != null) ? pCondition : (pCondition = new ConditionElements());
	}
	
	public ParserRule getConditionRule() {
		return getConditionAccess().getRule();
	}

	/// *
	// * Definition of action
	// * / Actions:
	//	{Actions} DO (actionList=ActionList | NOTHING);
	public ActionsElements getActionsAccess() {
		return (pActions != null) ? pActions : (pActions = new ActionsElements());
	}
	
	public ParserRule getActionsRule() {
		return getActionsAccess().getRule();
	}

	//ActionList:
	//	actions+=Action (SEMICOLON actions+=Action)* SEMICOLON?;
	public ActionListElements getActionListAccess() {
		return (pActionList != null) ? pActionList : (pActionList = new ActionListElements());
	}
	
	public ParserRule getActionListRule() {
		return getActionListAccess().getRule();
	}

	//// we really only want RETURN or THROW at the end of the list but try
	//// doing that without left recursion!
	//Action:
	//	Expression | ReturnExpr | ThrowExpr;
	public ActionElements getActionAccess() {
		return (pAction != null) ? pAction : (pAction = new ActionElements());
	}
	
	public ParserRule getActionRule() {
		return getActionAccess().getRule();
	}

	//// assigments ned to be composable just as any other operator expression
	//// but the LHS should only be an AccessExpr and not a constant expr
	//// enforcing the former requires left recursion -- or maybe backtracking?
	//// enforcing the latter maybe also requires backtracking? anyway we can
	//// just make assigment the weakest binding operator and do a post check
	//// to ensure the LSH of an assign is of the right type
	//Expression:
	//	AssignmentExpr;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//ReturnExpr returns Expression:
	//	op=KEYWORD_RETURN operand1=Expression?;
	public ReturnExprElements getReturnExprAccess() {
		return (pReturnExpr != null) ? pReturnExpr : (pReturnExpr = new ReturnExprElements());
	}
	
	public ParserRule getReturnExprRule() {
		return getReturnExprAccess().getRule();
	}

	//ThrowExpr returns Expression:
	//	op=KEYWORD_THROW operand1=Expression;
	public ThrowExprElements getThrowExprAccess() {
		return (pThrowExpr != null) ? pThrowExpr : (pThrowExpr = new ThrowExprElements());
	}
	
	public ParserRule getThrowExprRule() {
		return getThrowExprAccess().getRule();
	}

	/// *
	// * Definiton of Java expressions
	// * / // assignments have an LHS restricted to the different types of var
	//// expression and to fields and arrays. we have to allow access expressions
	//// and then typecheck out assignments to method members accesses, literals
	//// etc 
	//AssignmentExpr returns Expression:
	//	OperatorExpr ({AssignmentExpr.operand1=current} op=ASSIGN operand2=AssignmentExpr)?;
	public AssignmentExprElements getAssignmentExprAccess() {
		return (pAssignmentExpr != null) ? pAssignmentExpr : (pAssignmentExpr = new AssignmentExprElements());
	}
	
	public ParserRule getAssignmentExprRule() {
		return getAssignmentExprAccess().getRule();
	}

	//// other expressions are composed from either simple expressions or
	//// expressions involving member or array accesses using either unary
	//// or binary operators. a hierarchy of rules is used to ensure that
	//// operator precedence is respected. tighter binding operators appear
	//// lower down the hierarchy.
	//OperatorExpr returns Expression:
	//	PlusMinusOperand ({OperatorExpr.operand1=current} op=(PLUS | MINUS) operand2=PlusMinusOperand)*;
	public OperatorExprElements getOperatorExprAccess() {
		return (pOperatorExpr != null) ? pOperatorExpr : (pOperatorExpr = new OperatorExprElements());
	}
	
	public ParserRule getOperatorExprRule() {
		return getOperatorExprAccess().getRule();
	}

	//PlusMinusOperand returns Expression:
	//	TimesDivOperand ({PlusMinusOperand.operand1=current} op=(TIMES | DIV | MOD) operand2=TimesDivOperand)*;
	public PlusMinusOperandElements getPlusMinusOperandAccess() {
		return (pPlusMinusOperand != null) ? pPlusMinusOperand : (pPlusMinusOperand = new PlusMinusOperandElements());
	}
	
	public ParserRule getPlusMinusOperandRule() {
		return getPlusMinusOperandAccess().getRule();
	}

	//TimesDivOperand returns Expression:
	//	BitwiseOperand ({TimesDivOperand.operand1=current} op=(BAND | BOR | BXOR) operand2=BitwiseOperand)* | op=BNOT
	//	operand1=BitwiseOperand;
	public TimesDivOperandElements getTimesDivOperandAccess() {
		return (pTimesDivOperand != null) ? pTimesDivOperand : (pTimesDivOperand = new TimesDivOperandElements());
	}
	
	public ParserRule getTimesDivOperandRule() {
		return getTimesDivOperandAccess().getRule();
	}

	//BitwiseOperand returns Expression:
	//	(LogicalOperand | NotOperand) ({BitwiseOperand.operand1=current} op=(OR | AND) operand2=(NotOperand |
	//	LogicalOperand))*;
	public BitwiseOperandElements getBitwiseOperandAccess() {
		return (pBitwiseOperand != null) ? pBitwiseOperand : (pBitwiseOperand = new BitwiseOperandElements());
	}
	
	public ParserRule getBitwiseOperandRule() {
		return getBitwiseOperandAccess().getRule();
	}

	//NotOperand returns Expression:
	//	op=NOT operand1=LogicalOperand;
	public NotOperandElements getNotOperandAccess() {
		return (pNotOperand != null) ? pNotOperand : (pNotOperand = new NotOperandElements());
	}
	
	public ParserRule getNotOperandRule() {
		return getNotOperandAccess().getRule();
	}

	//LogicalOperand returns Expression:
	//	ComparisonOperand ({LogicalOperand.operand1=current} op=(EQ | GT | GE | LE | LT | NE) operand2=ComparisonOperand)*;
	public LogicalOperandElements getLogicalOperandAccess() {
		return (pLogicalOperand != null) ? pLogicalOperand : (pLogicalOperand = new LogicalOperandElements());
	}
	
	public ParserRule getLogicalOperandRule() {
		return getLogicalOperandAccess().getRule();
	}

	//// access base expressions can have array or member accesses composed on the right
	//ComparisonOperand returns Expression:
	//	AccessExpr;
	public ComparisonOperandElements getComparisonOperandAccess() {
		return (pComparisonOperand != null) ? pComparisonOperand : (pComparisonOperand = new ComparisonOperandElements());
	}
	
	public ParserRule getComparisonOperandRule() {
		return getComparisonOperandAccess().getRule();
	}

	//// we need to return the LHS type so we can recurse here
	//AccessExpr returns Expression:
	//	AccessBaseExpr ({AccessExpr.operand1=current} op=LSQUARE operand2=Expression RSQUARE | {AccessExpr.operand1=current}
	//	op=DOT value=ID args=CallArguments?)*;
	public AccessExprElements getAccessExprAccess() {
		return (pAccessExpr != null) ? pAccessExpr : (pAccessExpr = new AccessExprElements());
	}
	
	public ParserRule getAccessExprRule() {
		return getAccessExprAccess().getRule();
	}

	/// *
	//AccessExpr returns Expression :
	//	AccessBaseExpr ({AccessExpr.operand1 = current} access = Access)*
	//	;
	//	
	//Access :
	//	IndexAccess |
	//	MemberAccess
	//;
	//
	//IndexAccess:
	//{IndexAccess}
	//	LSQUARE (index=Expression) RSQUARE;
	//
	//MemberAccess :
	//  (op=DOT memberName=ID (args=CallArguments)?) ;
	// * / // access base expressions are either simple builtin calls or var references,
	//// literals, new expressions and bracketed expressions. they may possibly be
	//// accessed on the left before being composed with prefix or infix operators
	//AccessBaseExpr returns Expression:
	//	BuiltinExpr | SimpleExpr;
	public AccessBaseExprElements getAccessBaseExprAccess() {
		return (pAccessBaseExpr != null) ? pAccessBaseExpr : (pAccessBaseExpr = new AccessBaseExprElements());
	}
	
	public ParserRule getAccessBaseExprRule() {
		return getAccessBaseExprAccess().getRule();
	}

	//BuiltinExpr returns Expression:
	//	{BuiltinExpr} value=ID args=CallArguments;
	public BuiltinExprElements getBuiltinExprAccess() {
		return (pBuiltinExpr != null) ? pBuiltinExpr : (pBuiltinExpr = new BuiltinExprElements());
	}
	
	public ParserRule getBuiltinExprRule() {
		return getBuiltinExprAccess().getRule();
	}

	/// *
	// * TODO still need to allow for ternary (c ? e1 : e2) expressions
	// * / SimpleExpr returns Expression:
	//	VariableExpr | ConstantExpr | BracketedExpr | NewExpr;
	public SimpleExprElements getSimpleExprAccess() {
		return (pSimpleExpr != null) ? pSimpleExpr : (pSimpleExpr = new SimpleExprElements());
	}
	
	public ParserRule getSimpleExprRule() {
		return getSimpleExprAccess().getRule();
	}

	//NewExpr returns Expression:
	//	{NewExpr} op=NEW value=QualifiedName params=CallArguments;
	public NewExprElements getNewExprAccess() {
		return (pNewExpr != null) ? pNewExpr : (pNewExpr = new NewExprElements());
	}
	
	public ParserRule getNewExprRule() {
		return getNewExprAccess().getRule();
	}

	//VariableExpr returns Expression:
	//	SimpleName | IndexedSpecialVar | SpecialVar;
	public VariableExprElements getVariableExprAccess() {
		return (pVariableExpr != null) ? pVariableExpr : (pVariableExpr = new VariableExprElements());
	}
	
	public ParserRule getVariableExprRule() {
		return getVariableExprAccess().getRule();
	}

	//CallArguments:
	//	LPAREN {CallArguments} (args+=Expression (COMMA args+=Expression)*)? RPAREN;
	public CallArgumentsElements getCallArgumentsAccess() {
		return (pCallArguments != null) ? pCallArguments : (pCallArguments = new CallArgumentsElements());
	}
	
	public ParserRule getCallArgumentsRule() {
		return getCallArgumentsAccess().getRule();
	}

	//QualifiedName:
	//	ID (DOT ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return (pQualifiedName != null) ? pQualifiedName : (pQualifiedName = new QualifiedNameElements());
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//SimpleName returns Expression:
	//	{SimpleName} value=ID;
	public SimpleNameElements getSimpleNameAccess() {
		return (pSimpleName != null) ? pSimpleName : (pSimpleName = new SimpleNameElements());
	}
	
	public ParserRule getSimpleNameRule() {
		return getSimpleNameAccess().getRule();
	}

	//IndexedSpecialVar returns Expression:
	//	{IndexedSpecialVar} op=DOLLAR value=INTVAL;
	public IndexedSpecialVarElements getIndexedSpecialVarAccess() {
		return (pIndexedSpecialVar != null) ? pIndexedSpecialVar : (pIndexedSpecialVar = new IndexedSpecialVarElements());
	}
	
	public ParserRule getIndexedSpecialVarRule() {
		return getIndexedSpecialVarAccess().getRule();
	}

	//SpecialVar returns Expression:
	//	{SpecialVar} (op="$#" | op="$!" | op="$^" | op="$@" | op="$*" | op=DOLLAR value=ID);
	public SpecialVarElements getSpecialVarAccess() {
		return (pSpecialVar != null) ? pSpecialVar : (pSpecialVar = new SpecialVarElements());
	}
	
	public ParserRule getSpecialVarRule() {
		return getSpecialVarAccess().getRule();
	}

	//BracketedExpr returns Expression:
	//	LPAREN Expression RPAREN;
	public BracketedExprElements getBracketedExprAccess() {
		return (pBracketedExpr != null) ? pBracketedExpr : (pBracketedExpr = new BracketedExprElements());
	}
	
	public ParserRule getBracketedExprRule() {
		return getBracketedExprAccess().getRule();
	}

	//ConstantExpr returns Expression:
	//	IntConstantExpr | StringConstantExpr | BooleanConstantExpr | FloatConstantExpr;
	public ConstantExprElements getConstantExprAccess() {
		return (pConstantExpr != null) ? pConstantExpr : (pConstantExpr = new ConstantExprElements());
	}
	
	public ParserRule getConstantExprRule() {
		return getConstantExprAccess().getRule();
	}

	//IntConstantExpr returns Expression:
	//	{IntConstantExpr} value=INTVAL;
	public IntConstantExprElements getIntConstantExprAccess() {
		return (pIntConstantExpr != null) ? pIntConstantExpr : (pIntConstantExpr = new IntConstantExprElements());
	}
	
	public ParserRule getIntConstantExprRule() {
		return getIntConstantExprAccess().getRule();
	}

	//StringConstantExpr returns Expression:
	//	{StringConstantExpr} value=STRING;
	public StringConstantExprElements getStringConstantExprAccess() {
		return (pStringConstantExpr != null) ? pStringConstantExpr : (pStringConstantExpr = new StringConstantExprElements());
	}
	
	public ParserRule getStringConstantExprRule() {
		return getStringConstantExprAccess().getRule();
	}

	//BooleanConstantExpr returns Expression:
	//	{BooleanConstantExpr} value=BOOLEAN;
	public BooleanConstantExprElements getBooleanConstantExprAccess() {
		return (pBooleanConstantExpr != null) ? pBooleanConstantExpr : (pBooleanConstantExpr = new BooleanConstantExprElements());
	}
	
	public ParserRule getBooleanConstantExprRule() {
		return getBooleanConstantExprAccess().getRule();
	}

	//FloatConstantExpr returns Expression:
	//	{FloatConstantExpr} value=FLOATVAL;
	public FloatConstantExprElements getFloatConstantExprAccess() {
		return (pFloatConstantExpr != null) ? pFloatConstantExpr : (pFloatConstantExpr = new FloatConstantExprElements());
	}
	
	public ParserRule getFloatConstantExprRule() {
		return getFloatConstantExprAccess().getRule();
	}

	/// *
	//	Definition of terminal values
	// * / terminal QMARK:
	//	"?";
	public TerminalRule getQMARKRule() {
		return (tQMARK != null) ? tQMARK : (tQMARK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "QMARK"));
	} 

	//terminal COMMA:
	//	",";
	public TerminalRule getCOMMARule() {
		return (tCOMMA != null) ? tCOMMA : (tCOMMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMA"));
	} 

	//terminal DOT:
	//	".";
	public TerminalRule getDOTRule() {
		return (tDOT != null) ? tDOT : (tDOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOT"));
	} 

	//terminal COLON:
	//	":";
	public TerminalRule getCOLONRule() {
		return (tCOLON != null) ? tCOLON : (tCOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COLON"));
	} 

	//terminal NULL:
	//	"null";
	public TerminalRule getNULLRule() {
		return (tNULL != null) ? tNULL : (tNULL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NULL"));
	} 

	//terminal NEW:
	//	"new" | "NEW";
	public TerminalRule getNEWRule() {
		return (tNEW != null) ? tNEW : (tNEW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NEW"));
	} 

	//terminal SEMICOLON:
	//	";";
	public TerminalRule getSEMICOLONRule() {
		return (tSEMICOLON != null) ? tSEMICOLON : (tSEMICOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SEMICOLON"));
	} 

	//terminal BOOLEAN:
	//	"TRUE" | "true" | "FALSE" | "false";
	public TerminalRule getBOOLEANRule() {
		return (tBOOLEAN != null) ? tBOOLEAN : (tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN"));
	} 

	//terminal INIT:
	//	"<init>";
	public TerminalRule getINITRule() {
		return (tINIT != null) ? tINIT : (tINIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INIT"));
	} 

	//terminal CLINIT:
	//	"<clinit>";
	public TerminalRule getCLINITRule() {
		return (tCLINIT != null) ? tCLINIT : (tCLINIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CLINIT"));
	} 

	//terminal LPAREN:
	//	"(";
	public TerminalRule getLPARENRule() {
		return (tLPAREN != null) ? tLPAREN : (tLPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LPAREN"));
	} 

	//terminal RPAREN:
	//	")";
	public TerminalRule getRPARENRule() {
		return (tRPAREN != null) ? tRPAREN : (tRPAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RPAREN"));
	} 

	//terminal LSQUARE:
	//	"[";
	public TerminalRule getLSQUARERule() {
		return (tLSQUARE != null) ? tLSQUARE : (tLSQUARE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LSQUARE"));
	} 

	//terminal RSQUARE:
	//	"]";
	public TerminalRule getRSQUARERule() {
		return (tRSQUARE != null) ? tRSQUARE : (tRSQUARE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RSQUARE"));
	} 

	//terminal DOLLAR:
	//	"$";
	public TerminalRule getDOLLARRule() {
		return (tDOLLAR != null) ? tDOLLAR : (tDOLLAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOLLAR"));
	} 

	//terminal PLUS:
	//	"+";
	public TerminalRule getPLUSRule() {
		return (tPLUS != null) ? tPLUS : (tPLUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PLUS"));
	} 

	//terminal MINUS:
	//	"-";
	public TerminalRule getMINUSRule() {
		return (tMINUS != null) ? tMINUS : (tMINUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MINUS"));
	} 

	//terminal MOD:
	//	"%";
	public TerminalRule getMODRule() {
		return (tMOD != null) ? tMOD : (tMOD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MOD"));
	} 

	//terminal DIV:
	//	"/";
	public TerminalRule getDIVRule() {
		return (tDIV != null) ? tDIV : (tDIV = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DIV"));
	} 

	//terminal TIMES:
	//	"*";
	public TerminalRule getTIMESRule() {
		return (tTIMES != null) ? tTIMES : (tTIMES = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TIMES"));
	} 

	//terminal BAND:
	//	"&";
	public TerminalRule getBANDRule() {
		return (tBAND != null) ? tBAND : (tBAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BAND"));
	} 

	//terminal BOR:
	//	"|";
	public TerminalRule getBORRule() {
		return (tBOR != null) ? tBOR : (tBOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOR"));
	} 

	//terminal BNOT:
	//	"~";
	public TerminalRule getBNOTRule() {
		return (tBNOT != null) ? tBNOT : (tBNOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BNOT"));
	} 

	//terminal BXOR:
	//	"^";
	public TerminalRule getBXORRule() {
		return (tBXOR != null) ? tBXOR : (tBXOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BXOR"));
	} 

	//terminal LT:
	//	"<";
	public TerminalRule getLTRule() {
		return (tLT != null) ? tLT : (tLT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LT"));
	} 

	//terminal LE:
	//	"<=";
	public TerminalRule getLERule() {
		return (tLE != null) ? tLE : (tLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LE"));
	} 

	//terminal GT:
	//	">";
	public TerminalRule getGTRule() {
		return (tGT != null) ? tGT : (tGT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GT"));
	} 

	//terminal GE:
	//	">=";
	public TerminalRule getGERule() {
		return (tGE != null) ? tGE : (tGE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GE"));
	} 

	//terminal EQ:
	//	"==";
	public TerminalRule getEQRule() {
		return (tEQ != null) ? tEQ : (tEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EQ"));
	} 

	//terminal NE:
	//	"!=";
	public TerminalRule getNERule() {
		return (tNE != null) ? tNE : (tNE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NE"));
	} 

	//terminal ASSIGN:
	//	"=";
	public TerminalRule getASSIGNRule() {
		return (tASSIGN != null) ? tASSIGN : (tASSIGN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ASSIGN"));
	} 

	//terminal FLOATVAL:
	//	"0".."9"+ "." "0".."9"* EXPONENT? FLOATTYPESUFFIX? | "." "0".."9"+ EXPONENT? FLOATTYPESUFFIX? | "0".."9"+ EXPONENT
	//	FLOATTYPESUFFIX? | "0".."9"+ FLOATTYPESUFFIX;
	public TerminalRule getFLOATVALRule() {
		return (tFLOATVAL != null) ? tFLOATVAL : (tFLOATVAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FLOATVAL"));
	} 

	//terminal INTVAL:
	//	"0".."9"+ INTTYPESUFFIX? | "0x" ("0".."9" | "A".."F" | "a".."f")+ INTTYPESUFFIX? | "0b" "0".."1"+ INTTYPESUFFIX?;
	public TerminalRule getINTVALRule() {
		return (tINTVAL != null) ? tINTVAL : (tINTVAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INTVAL"));
	} 

	//// these are defined as fragments so they only get tokenized in the
	//// context of tokenizing a floating point value
	//terminal fragment EXPONENT:
	//	("e" | "E") ("+" | "-")? "0".."9"+;
	public TerminalRule getEXPONENTRule() {
		return (tEXPONENT != null) ? tEXPONENT : (tEXPONENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EXPONENT"));
	} 

	//terminal fragment FLOATTYPESUFFIX:
	//	"f" | "F" | "d" | "D";
	public TerminalRule getFLOATTYPESUFFIXRule() {
		return (tFLOATTYPESUFFIX != null) ? tFLOATTYPESUFFIX : (tFLOATTYPESUFFIX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FLOATTYPESUFFIX"));
	} 

	//terminal fragment INTTYPESUFFIX:
	//	"L" | "l";
	public TerminalRule getINTTYPESUFFIXRule() {
		return (tINTTYPESUFFIX != null) ? tINTTYPESUFFIX : (tINTTYPESUFFIX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INTTYPESUFFIX"));
	} 

	//terminal OR:
	//	"OR" | "or" | "||";
	public TerminalRule getORRule() {
		return (tOR != null) ? tOR : (tOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "OR"));
	} 

	//terminal AND:
	//	"AND" | "and" | "&&";
	public TerminalRule getANDRule() {
		return (tAND != null) ? tAND : (tAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "AND"));
	} 

	//terminal NOT:
	//	"NOT" | "not" | "!";
	public TerminalRule getNOTRule() {
		return (tNOT != null) ? tNOT : (tNOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NOT"));
	} 

	//terminal KEYWORD_CLASS:
	//	"CLASS" | "class";
	public TerminalRule getKEYWORD_CLASSRule() {
		return (tKEYWORD_CLASS != null) ? tKEYWORD_CLASS : (tKEYWORD_CLASS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KEYWORD_CLASS"));
	} 

	//terminal KEYWORD_METHOD:
	//	"METHOD" | "method";
	public TerminalRule getKEYWORD_METHODRule() {
		return (tKEYWORD_METHOD != null) ? tKEYWORD_METHOD : (tKEYWORD_METHOD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KEYWORD_METHOD"));
	} 

	//terminal KEYWORD_INTERFACE:
	//	"INTERFACE" | "interface";
	public TerminalRule getKEYWORD_INTERFACERule() {
		return (tKEYWORD_INTERFACE != null) ? tKEYWORD_INTERFACE : (tKEYWORD_INTERFACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KEYWORD_INTERFACE"));
	} 

	//terminal IF:
	//	"IF" | "if";
	public TerminalRule getIFRule() {
		return (tIF != null) ? tIF : (tIF = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "IF"));
	} 

	//terminal KEYWORD_BIND:
	//	"BIND" | "bind";
	public TerminalRule getKEYWORD_BINDRule() {
		return (tKEYWORD_BIND != null) ? tKEYWORD_BIND : (tKEYWORD_BIND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KEYWORD_BIND"));
	} 

	//terminal NOTHING:
	//	"NOTHING" | "nothing";
	public TerminalRule getNOTHINGRule() {
		return (tNOTHING != null) ? tNOTHING : (tNOTHING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NOTHING"));
	} 

	//terminal KEYWORD_THROW:
	//	"THROW" | "throw";
	public TerminalRule getKEYWORD_THROWRule() {
		return (tKEYWORD_THROW != null) ? tKEYWORD_THROW : (tKEYWORD_THROW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KEYWORD_THROW"));
	} 

	//terminal KEYWORD_RETURN:
	//	"RETURN" | "return";
	public TerminalRule getKEYWORD_RETURNRule() {
		return (tKEYWORD_RETURN != null) ? tKEYWORD_RETURN : (tKEYWORD_RETURN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "KEYWORD_RETURN"));
	} 

	//terminal DO:
	//	"DO" | "do";
	public TerminalRule getDORule() {
		return (tDO != null) ? tDO : (tDO = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DO"));
	} 

	//terminal START_RULE:
	//	"RULE" WS->EOL | "rule" WS->EOL;
	public TerminalRule getSTART_RULERule() {
		return (tSTART_RULE != null) ? tSTART_RULE : (tSTART_RULE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "START_RULE"));
	} 

	//terminal END_RULE:
	//	"ENDRULE" | "endrule";
	public TerminalRule getEND_RULERule() {
		return (tEND_RULE != null) ? tEND_RULE : (tEND_RULE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "END_RULE"));
	} 

	//terminal ID:
	//	("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "$" | "0".."9")*;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" | "n" |
	//	"f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//terminal BM_COMMENT:
	//	HASH->EOL;
	public TerminalRule getBM_COMMENTRule() {
		return (tBM_COMMENT != null) ? tBM_COMMENT : (tBM_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BM_COMMENT"));
	} 

	//terminal HASH:
	//	"#";
	public TerminalRule getHASHRule() {
		return (tHASH != null) ? tHASH : (tHASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HASH"));
	} 

	//terminal EOL:
	//	"\n" | "\r";
	public TerminalRule getEOLRule() {
		return (tEOL != null) ? tEOL : (tEOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EOL"));
	} 

	//terminal WS:
	//	" " | "\t";
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 
}
